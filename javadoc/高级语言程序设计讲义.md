# **主题** **1.	Java** **程序语言**

## **内容提要**

本主题的第一部分介绍了有关程序和程序语言的基本知识，如何学习程序语言。第二部分介绍了 Java 程序语言的基本特质和 Java 程序的工作原理。 本主题是本课程的引入模块，帮助同学们了解计算机程序的基本知识和 Java 语言的基本特征及其工作原理，对于后面 Java 程序学习是很重要，因此必须掌握。

## **学习目标**

学完本模块以后，你应该能够

· 解释程序/语句/面向对象/面向过程等基本概念

· 复述程序的工作原理/Java 程序的工作原理

·列举计算机程序语言的发展阶段，列举 Java 程序语言的主要特征

## **重点难点**

· 解释语言和编译语言的差异

· 面向过程和面向对象的差异

·Java 程序的工作原理

## **学习内容**

模块 1	 	 程序和程序语言（建议学习时间：30 分钟）计算机程序的基本知识																								

模块 2	 	 Java 程序语言（建议学习时间：30 分钟）	 	 Java 语言的历史、Java语言的特点和工作原理。

模块 3（选学：30 分钟）如何学习 Java 程序设计	 	 如何学习程序设计、如何学习 Java 程序语言



## 模块1，程序和程序语言

### 一、计算程序是什么

计算机程序也叫软件，它告诉计算机该做什么。计算机执行的任何操作（从启动到关机）都是由程序控制的。Windows	XP、Ubantu	Linux 这类的操作系统是程序；用于浏览网页的浏览器是程序；QQ 是程序；星际争霸、帝国时代这类游戏也是程序；甚至是在我们电脑中捣蛋的各种病毒也是程序！在日常生活中我们会有很多这样的体验，父母、老师或者同学有的时候需要你帮他们做事情，他们对你需要做的事情的安排和表述就相当于是给你的指令，告诉你该做什么。例如在某个周末，你下班回到家，看到您爱人给你留下的便条：

亲爱的，我有急事出差两天，这两天你要做的事情有： 

· 收拾屋子

· 去超市买水龙头

· 洗衣服

· 买菜做饭

在完成上面这些事情的过程中，我们可以很灵活的安排事情的先顺序，可以先买菜，也可以先收拾屋子。在做某件事情的时候也可以灵活处理：去买菜也一定是根据自己的需要和市场里面供应的品种购买，而不是机械的买一两样等等。

人在接到命令后，会很灵活地去执行各项任务；而计算机没有这么灵活，它们严格地按命令执行。**程序**由一系列命令组成，程序运行时，计算机按特定顺序处理这些命令。每一行就是**语句**。计算机按顺序处理和执行程序中的每一条语句，这种做法就想厨师按照菜谱的顺序炒菜一样。每个程序都精确地执行，每次只能执行一条语句。

下面表格的左侧是一个 Java 程序片段，右侧是对程序的解读。从这段程序中我们可以大概了解每行的意思

```
if(isGameOver	==	true){
System.out.println("游戏结束！");
}else{
	 	 System.out.println("请重新再玩一次
");
}

如果游戏已经结束
				 显示：“游戏结束”
	 	 否则
				 显示：“请重新再玩一次”
```

```
Public	class	test{
Public	static	void	main(String[]	args){
Int	i=10,j=3;
System.out.println(i/j);
System.out.println(i+j);
System.out.println(i-j);
}
}

程序执行 10/3 后，输出：3
程序执行 10+3 后，输出：13
程序执行 10-3 后，输出：7
```

计算机是按照预先编写的命令执行任务的，因此除非是计算机硬件出现故障或者是讨厌的病毒攻击了系统而造成的错误，在程序运行过程中发生任何错误，都是程序员的问题，因为计算机只是按照程序指令在执行操作。编程人员在这个时候就应该好好地检查程序的设计是否有问题。从现在开始，大胆尝试吧，你不用担心编程错误会搞坏计算机硬件。

### 二、编程语言的发展历程

人类的语言是一个渐变发展的过程，直至今天仍在不断改进，同样，计算机程序语言也不是一步到位，而是经历了一个从面向机器语言，到面向过程语言，再到今天的面向对象语言的发展过程。电子计算机所使用的是由“0”和“1”组成的二进制数，二进制是计算机的语言的基础。计算机发明之初，人们只能降贵纡尊，用一串串由“0”和“1”组成的各种指令操纵计算机，这种语言就是**机器语言**。使用机器语言是十分痛苦的，在程序有错需要修改时更是如此。而且，由于每台计算机的指令系统往往各不相同，所以，在一台计算机上执行的程序，如果要移植到另一台计算机上必须另编程序，造成了重复浪费。但由于使用的是针对特定型号计算机的语言，故而运算效率是所有语言中最高的。

为了减轻直接使用机器语言编程的痛苦，科学家们发明了一种新语言，用一些简洁的英文字母、符号串来替代一个特定的指令的二进制串，比如，用“ADD”代表加法，“MOV”代表数据传递等等，这样一来，人们很容易读懂并理解程序在干什么，纠错及维护都变得方便了，这种程序设计语言就称为**汇编语言**。

在汇编语言的基础上，科学家们意识到，应该设计一种接近于数学语言或人的自然语言，同时又不依赖于计算机硬件，编出的程序能在所有机器上通用的语言，这类语言后来被称为**高级语言**。经过努力，他们发明了Fortran语言。随后又根据应用的领域不同，和设计思想的不同，陆续发明了C语言、Pascal语言和BASIC语言等，这类语言关注做事情的先后顺序，因而被称为**面向过程语言**。它们用接近数字语言的方式进行程序设计，加快了编程速度，也能使得人们能够把注意力从繁琐的硬件细节转向集中算法本身。

面向过程的语言也有一定的局限性：现实世界是复杂多变的，往往不能简单归结于先后顺序和数学模型。因此，科学家们又发明了**面向对象语言**，如SmallTalk，LISP，Java，C#语言等。面向对象的编程语言解决了传统结构化方法中问题空间和解空间在结构上不一致的问题，避免从分析和设计到软件模块结构间的多次转换过程，使软件开发变得简单、高效、合理，是真正最接近人类思维方式的计算机程序设计语言。关注对象和对象之间的交互。

![image-20220716230143892](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220716230143892.png)

学习编程的关键是**选择正确的编程语言**。新语言的出现不代表旧语言的没落。在有上百种高级语言的今天，汇编语言在单片机编程等方面还是被广泛使用。**不同的语言适合于不同的领域和任务要求，任何编程语言都有其最适合完成的工作，也有最不适合用来完成的工作。我们需要依据要求计算机完成的任务来选择编程语言。

### 三、程序的工作原理

```
程序的工作原理（图解）
使用编辑器 ->	 编写源程序 ->	 解释执行
->	 编译->	 获得二进制代码->执行二进制文件
```

前面我们了解到，计算机能够从程序中读取命令、并执行，因此要操作计算机的第一步是写程序。写程序就要用到编程工具，编程工具和程序的关系就像Word和用Word写的文章的关系：我们用Word写文章，那么Word软件就像是我们的编程工具，而文章就是我们编写的**源程序**，源程序可以被程序语言的解释器解释执行或直接编译成二进制代码执行。

有些语言需要解释器来运行程序，解释器是对每条计算机程序的语句进行解释的程序。此时程序、解释器和计算机的关系就像是英国人、翻译人员和中国人的关系，英国人和中国人说的话互相不理解，程序和计算机之间也一样，计算机不能直接明白程序的意思，这时需要一位翻译人员在中间进行翻译解释，此时的解释器就像是这位翻译人员，读取程序中的每条语句，然后告诉计算机做什么。

另外一些编程语言需要先编译后运行，编译器也像上面的翻译人员一样，将计算机程序翻译成计算机能够理解的格式。运行的时候直接运行翻译后的结果即可。

还有一些编程语言兼有两者的特点，如Java，将在后面详细解释。

```
【提示】：绝大多数的程序语言，其源程序是纯文本格式的，我们可以用文本编辑器，如记事本，写字板甚至是 Word打开编辑。但是在再次保存的时候一定要保存为纯文本格式。

```

解释方式和编译方式各有优缺点，比较如下表：

|          | 优点                                                         | 缺点                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 解释方式 | 可以快速进行测试：使用解释型语言编写程序时，可以立即进行测试，找出错误并修正，然后再试； | 运行速度比其他程序慢；                                       |
| 编译方式 | 它尽可能地对程序进行优化，使其高效运行。编译后的程序不需要解释器就可直接运行，且运行速度比解释型程序快； | 但测试起来需要更多的时间。在测试前，需要编写并编泽程序。发现错误并修改后，必须重新编译，以确定错误是否已消除； |

```
问：什么是源程序？
回答：编写好计算机程序后，需要像保存Word文档一样将其保存。计算机程
序通常有独特的扩展名，用于指定其文件类型，如同Word文档的扩展名是.doc
一样，C语言程序的扩展名是.c，Java程序语言的扩展名为.java，如
HelloWorld.java是一个Java源程序。这里的HelloWorld是该java程序的文件
名，.java说明这个文件的类型。
```

## 模块二 Java 编程语言概述

### 一、**Java** 的起源和发展历程

**早期的 Java** 

Java 平台和语言最开始只是 Sun 公司在 1990 年 12 开始研究的一个内部项目“Green 计划”。其目的是研究开发新技术，瞄准下一代智能家电（如微波炉）的程序设计，Sun 公司预料未来科技将在家用电器领域大显身手。该项目就是为家用消费电子产品开发一个分布式代码系统，以便用户将 E-mail 发送给电冰箱、电视机、烤箱等家用电器，对它们进行控制，并和它们进行信息交换。

团队最初考虑使用 C++语言，但是项目组成员很快发现 C++和可用的 API在某些方面存在很大问题。工作小组使用的是内嵌类型平台，可以用的资源极其有限。C++语言是一种功能强大但比较复杂的语言，以至很多开发者经常错误使用，而且 C++缺少垃圾回收系统、可移植的安全性、分布程序设计和多线程功能。最后项目组成员基于 C++开发了一种新的语言 Oak（橡树），这就是Java 语言的前身。但是由于这些智能化家电的市场需求没有预期的高，Sun 公司放弃了该项计划；因 Oak 是一种用于网络的精巧而又安全的的语言，Sun 公司又曾依此投标了一个交互式电视节目，但结果又被 SGI 打败，Oak 几乎夭折。

**Java 遭遇互联网**

1994 年 6、7 月间，在经历了一场历时三天的头脑风暴的讨论后，团队决定再一次改变努力的目标，这次他们决定将该技术应用于万维网。他们认为随着 Mosaic 浏览器的到来，因特网正在向同样的高度互动的远景演变，而这一远景正是他们在有线电视网中看到的。于是，Java 的重心由电子消费品转移到 Internet 编程，因此 Green 计划就此绝地逢生，随着互联网蓬勃发展。Internet 最终导致了 Java 的成功，在 1995 年 5 月 Sun 公司以“Java”的名称正式发布了该语言。1996 年 1 月，Sun 公司成立了 Java 业务集团，专门开发 Java 技术。 Java 语言伴随着 Internet 的迅猛发展，逐渐成为重要的Internet 编程语言。

**Java 近况**

在流行几年之后，Java 在浏览器中的地位被逐步侵蚀。它在简单交互性动画方面的用途已经完全被 Macromedia 公司的 Flash 排挤，2005 年 Java 倾向只被用于雅虎游戏那样的更为复杂的应用程序。Java 同时遭受到来自微软的反对，他们决定在新版本的 IE 浏览器和 Windows 中不再附带 Java 平台。与此相反，在万维网的服务端和手持设备上，Java 变得更加流行，很多网站在前端都使用了 JSP 和其他的 Java 技术。在桌面系统上，独立的 Java 程序还是相对少见，这是因为 Java 平台的运行开销较大，而许多人的电脑上没有安装 Java，由于网络带宽在以前较小，下载 Java 曾经是个耗时的事情。但是随着计算机计算能力、网络带宽在 10年中取得了很大的进步，同时虚拟机和编译器的质量得到了越高，许多应用程序得到了广泛的使用，还有许多用 Java 写的软件。

目前 Java ᨀ供以下三个版本：标准版、企业版和微型版（J2SE、J2EE、J2ME）。

关于 Java 这个名字的来历还有一段趣闻：有一天，几位 Java 成员组的会员正在讨论给这个新的语言取什么名字，当时他们正在咖啡馆喝着 Java(爪哇)咖啡，有一个人灵机一动说就叫 Java 怎样，这个ᨀ议得到了其他人的赞同，于是，Java 这个名字就这样传开了。

关于 java 的咖啡图标，也有悠闲的意思，就是说使用java 语言可以有更好的开发效率，给你更多悠闲的时间（喝咖啡），还有一杯咖啡放在你的面前，你是不是有一种要把它端起来的冲动呢？其实就是让你体验 java 的冲动。

### 二、Java发展历史的简单回顾

**幼年时期（****1995****～****1998****）**

1995 年 5 月 23 日，java 语言诞生；1996 年 1 月 23 日，第一个 JDK——JDK1.0 诞生，此版本包括了运行环境（JRE）和开发环境（JDK）两部分；

1997 年 2 月 18，JDK1.1 发布，最大改进就是为 JVS 增加了 JIT（即时编译）编译器；

**青少年时期（****1998****～****2004****）**

1998 年 12 月 4 日，Sun 发布了 Java 的历史上最重要的一个 JDK 版本：JDK1.2。此版本标志着 Java 已经进入 Java2 时代；

1999 年 6 月 SUN 公司发布 Java 的 3 个版本，即标准版、企业版和微型版（J2SE、J2EE、J2ME）；

2000 年 5 月 8 日，JDK1.3 发布；

2000 年 5 月 29 日，JDK1.4 发布；

2001 年 9 月 24 日，J2EE1.3 发布；

2002 年 2 月 26 日，J2SE1.4 发布，自此 java 的计算能力有了大幅度的升；

**壮年时期（****2004****～至今）**

2004 年 9 月 30 日，J2SE1.5 发布，是 java 语言发展史上又一里程碑事件。为了表示这个版本的重要性，J2SE1.5 更名为 J2SE5.0；

2006 年 Sun 推出了 J2SE6.0 测试版；

1、 Java 由 SUN 公司研发，后来被 Oracle 收购

2、Java 之父：James Gosling

3、Java 由 1995 年发布，正事版本由 1996 年1月发布（jdk1.0）



### 三、Java 的特点

Java 语言和 C++语言有不小的渊源，但是没有 C++语言那么复杂，它是一种安全、简单、容易使用的语言，因而在从移动平台到企业级平台各个领域得到广泛的应用，值得大家去花时间学习和研究。业界用了很多词汇来表述 Java 的特点，总结起来主要有：

**简单**

Java 最初是为对家用电器进行集成控制而设计的一种语言，因此它必须简单明了。Java 语言的简单性主要体现在：Java 的风格类似于 C++，因此 C++程序员可以很快地掌握 Java 编程技术；同时 Java 摒弃了 C++中容易引发程序错误的一些特性，如：指针、结构、枚举以及内存管理等；此外，Java 提供了丰富的类库，可以方便的开发出各种应用程序。

**面向对象**

Java 语言从设计思想上就是完全面向对象的，不同于 C 语言那样的面向过程的程序设计语言，面向对象的概念构成了 Java 的核心面向对象的程序设计方法就是按照现实世界的特点来管理复杂的事物，把各种事物抽象为对象，具有自己的状态和行为，通过对消息的反应来完成一定的任务，结合现实世界举例来说，一条黄狗就是一个对象，它具有自己的状态：身长 1 米，颜色是黄色；它具有自己的行为：跑、跳、爬等，并通过主人的命令，也就是消息来执行各种任务。将现实世界表达在程序中，我们就用数据表明对象的状态，方法表明对象所具有的行为，**一个对象就是数据和相关的方法的集合。**

**分布性**

Java 诞生于互联网的时代，它是面向网络的语言。Java 的程序能够从网络上的不同的地点获得您所要的资源，包括数据文件、影像文件、声音文件等，并传送到您的计算机，并加以处理，所以说 Java 是一种网络语言。

**健壮性**

Java 程序语言在设计上采取“未雨绸缪”的策略，将重点放在早期潜在问题检查及运行时检查上，以消除错误的产生，有效地提高了程序的健壮性。Java 中具有健壮性的设计包括垃圾收集和数组越界检查等。

**安全性**

用于网络、分布环境下的 Java 必须要防止病毒的入侵。JAVA 编译器并不控制内存分配，只在程序运行时，由操作系统分配，有效避免了不友善代码或病毒程序入侵。这样就好像我们给计算机的安全大门加了把锁，而此时的网络也像是一团烟雾，我们在访问远端服务器时，只需利用网络而不用考虑甚至是担心网络中的各种不安全因素。

![image-20220716235022118](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220716235022118.png)

**可移植性**

也叫平台无关性。Java 是一种“**一次编写，到处运行**”的语言。Java 源程序被编译成一种与机器无关的字节码格式，这是一种结构中立的中间文件格式，只要有 Java运行系统的机器都能执行这种中间代码。因此 Java 程序可以方便的从一种操作系统不加改动或只做很少改动移植到另一种系统，。源程序在编译后就可通过各种操作系统（Windows、UNIX 等）中安装的 Java 虚拟机（JVM）来运行。Java 虚拟机（JVM）会在后继中进行介绍。跨平台移植 ---- JVM Java 虚拟机

**多线程**

Java 对多线程的支持，有效实现了多个任务的并发执行，这样就很容易地实现网络上的实时交互行为。

就好像我们做一张桌子，如果你一个人完成这张桌子——就好像单线程，那么你需要先做桌面，做完桌面后，再做 4 个桌子

腿，如果现在有 5 个人来做桌子——在程序中开辟 5 个线程，其中 1 个人做桌面，另外 4 个人分别做 4 个桌子腿，那么这两种方

式效率的高低，相信大家都能区分出来。如下图中所示，在 Java 虚拟机（JVM）中运行的某程序被分为了三个线程同时运行不同的操作。

![image-20220716235308037](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220716235308037.png)

**动态性**

Java 的设计使它非常适合于一个不断变化发展的环境。在类库中可以自由地加入新的方法和成员变量以适应复杂多变的外界环境，而不会影响用户程序的执行。

总之，Java 的最大优点是与操作系统无关，在多种操作系统上，都可以使用相同代码；同时它围绕网络应用开发，最大限度的利用网络资源，它的小程序 Java Applet 在网络上的传输不受 CPU 和环境限制；另外 Java 提供了丰富的类库，为编程人员ᨀ供快速和标准的应用接口，提高了软件的生产率，它的安全性也极高。这正是 Java 成为网络应用开发主流语言的原因。

### **四、Java** **的工作原理**

前面我们已经向大家介绍过编程语言的工作原理，Java 语言的工作原理也类似。Java 程序开发都要经过三个基本步骤，即编辑、编译和运行（如下图所示）。

![image-20220716235541302](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220716235541302.png)

1. 编辑。就是采用编辑器编写 Java 源程序，也就是编写程序代码的过程，其存储后的文件后缀为“.java”，如 HelloWorld.java。

2. 编译。将 Java 源文件编译成一个与此类类名相同但后缀为.class 的字节码文件，如通过编译完成之后，HelloWorld.java（源程序文件）将生成对应的 HelloWorld.class（字节码文件）。

3. 运行。就是使用 Java 解释器运行 Java 字节代码。通过下达执行命令，解释器就会运行 HelloWorld.class（字节码文件），最后在窗口中输出 运行结果：Hello	World！

   在程序的工作原理中我们ᨀ到，Java 的独特之处在于同时需要编译器和解释器，**Java 虚拟机（JVM）**是编译和运行 Java 程序等各种命令及其运行环境的总称。java 虚拟机是软件模拟的计算机，可以在任何处理器上 （无论是在计算机中还是在其它电子设备中）安全并且兼容的执行保存在.class 文件中的字节码。java 虚拟机的"机器码"保存在.class 文件中， 有时也可以称之为字节码文件。java 程序的跨平台主要是指字节码文件可以在任何具有java 虚拟机的计算机或者电子设备上运行，java 虚拟机中的 java 解释器负责将字节码文件解释成为特定的机器码进行运行。java 源程序需要通过编译器编译成为.class 文件（字节码文件）

   **编译器**就是来完成 Java 源程序编译的，就是把编写好的 Java 源程序编译生成为字节码文件，这种字节码实际上是一种伪代码，它包含各种指令，而这些指令基本上是与平台无关的指令。Java 源程序编译生成的字节码不能直接在一般的操作系统上运行，因此需要解释器再进一步翻译成计算机能执行的机器码。

   **解释器**是在 Java 程序运行时将编译器生成的字节码进一步翻译成机器码，继而由本地计算机执行该机器码。Java 虚拟机在字节码文件（即编译生成的后缀为“.class”的文件）的基础上**解释这些字节码**，即将这些字节码转换成为本地计算机平台的机器代码，并交给本地计算机执行。

   在引入 Java 语言虚拟机后,Java 语言在不同平台上运行时不需要重新编译。也就是说,无论你用的是什么操作系统,无论你用什么电脑,只要安装了Java 虚拟机就可以运行 Java 程序,这样做的优点是可以大量减少开发人员的工作量,一次开发到处运行!你也可以不必担心 Java 软件是否匹配你的操作系统。这就是 Java 程序为什么能够跨平台运行、解决可移植性问题的主要原因，因此从上图我们可以看到同一 Java 程序经解释执行后可在 Windows、UNIX 等各种不同的操作系统上运行。

   那么 Java 程序的安全性问题也交给了 Java 虚拟机完成，Java 虚拟机提供了完善的安全机制。Java 安全模式的重点在于保护最终用户不受从网上下载的破坏性程序的干扰。为达到这个目的，Java 提供了一个专用的运行 Java程序的隔离区。Java 程序在它的隔离区内可做任何事情，但出此边界就不能再有任何操作了。例如，未经确认的 JavaApplet 的沙箱禁止读写本地磁盘。通过限定下载代码的可执行操作的范围，Java 安全模式可使用户免受破坏性程序的威胁。

   Java 的程序有两种模式：Java 应用程序和 Java 小应用程序（Java	applet）。两种模式的主要区别在于：应用程序可以独自执行而小应用程序必须在浏览器中启动。

   

### **五、java** **的垃圾收集机制**

垃圾收集是指 Java 虚拟机释放不再使用的对象所占用内存的活动。在程序中，每个对象都会分配一定的内存，就像每位职工都会分配一套房子一样。在 C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象；而在 Java 中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。举例来说就是在 C++中一旦房子分配给了职工，无论职工是否使用该房，此房都始终属于该职工，而不会分配给那些没房而又需要房的职工，直到明确要求此房不再属于该职工；而在 Java 中虽然房子已分配给了职工，可如果职工长期不使用该房，那么该房就会被收回。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。

事实上，除了释放没用的对象，垃圾收集也可以清除内存记录碎片。由于创建对象和垃圾收集器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存块。碎片整理功能将所占用的内存块移 到内存堆的一端，将整理出的内存分配给新的对象。垃圾收集和内存整理可以帮助虚拟机获得更高的效率。

有一点需要注意的是，由于垃圾收集动作本身会占用系统资源，因此不是什么时候都会发生，JVM 只有在内存即将耗尽的时候，才会进行垃圾收集已腾出内存空间。

![image-20220717142308723](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717142308723.png)

```
【人物小百科】Java 之父：James	Gosling
James	Gosling 以“Java	 技术之父”而闻名于世。他是 Java语言，并开发了 Java 编译器和 Java 虚拟机，支持的计算模式，已经成为了互联网的标准编程模式以及分布式企业级应用的事实标准。 
James	Gosling 从小就喜欢技术，爱鼓捣东西。的部件做了一台电子游戏机。附近农民的康拜因（联合收割机14 岁的时候，中学组织到附近大学参观，他记住了大学计算中心的门锁密码偷地溜进计算中心，学习计算机编程。一年后，大学的天文系招他当了一名临时编程员编写计算机程序来分析卫星天文数据。
80 年代初，James	Gosling 获得博士学位后到 IBM 工作，设计 IBM 第一代工作站。当时，IBM的领导层并不看重工作站项目。失望之余，James	 Gosling 跳槽到了 Sun 公司。他花了五年功夫领导开发的和 OS2 很类似的 Sun	 NeWs 窗口系统，尽管得到技术界的好评，却未能变成流行的产品。当时他还第一个用 C 实现的 EMACS 的所见即所得文本编辑器 COSMACS。
1990 年，Sun 公司成立了一个软件设计团队，其中除了 James	Gosling，还有 Patrick	Naughton和 Mike	 Sheridan 等人，他们合作的项目称为“绿色计划”。他们认为计算机技术发展的一个趋势是数字家电之间的通讯。James 开始负责为设备和用户之间的交流创建一种能够实
现网络交互的语言。随着大量的时间和金钱投入到“绿色计划”，他们创建了一种语言。这种语言一开始被叫做“Oak”，这个名字得自于 Gosling 想名字时看到了窗外的一棵橡树。但后来被改为了“Java”。并于 1992 年 9 月 3 日开始应用于 Sun 工作站的远程遥控。1994 年底，James Gosling 参加了在硅谷召开的“技术、教育和设计大会”。他报着试一试的心情向与会者演示了 Java 的功能。他点击了网页上的一个静止的分子结构图标，一条命令通过互联网送到了几百英里外的网站，下载了一段 Java 小程序，在本地工作站上开始执行。在几秒钟时间里，原本静止的网页上，一个分子图像以三维动画的方式转了起来。到了 2000 年，Java 已经成为世界上最流行的电脑语言。绿色小组当初设计 Java 是为了面
向数字家庭，支持各种家电设备。他们没有想到的是，Java 支持的计算模式，实际上就是互联网的模式。
对于 Java 语言的巨大成功，没有人比 James	Gosling	 更加谦逊：“我从来没有想到 Java 技术将会这么火。当我的老板问我它将达到多少次下载时，我说 10,000	 次。而他认为我太过乐观了。” 目前，Gosling 先生积极致力于研究软件开发工具，使它们功能更为强大，更容易为开发人员所使用，能够快速地开发应用。
```

## 模块三、**如何学习** **java** **程序设计**

### 一、**如何学习程序设计**

1. 培养学习兴趣

首先我们来看看程序设计学习要点，学习任何一门程序设计语言，首先**要有学习兴趣**，对这一点来讲，无容置疑。如果没有兴趣，那么很 可能花大量的时候收到的效果也不是很好。做任何事情，如果有兴趣则可事半功倍，如果仅仅是为了你的谋生的话，那么学习程序设计语言可能就比较艰难，这是第 一点，要慢慢培养兴趣。培养兴趣的话可以参考一些 IT 史话，看一些历史发展中的名人，了解他们的一些事迹，来培养学习的兴趣。

2. 慎选程序设计语言

男怕入错行，女怕嫁错郎。程序语言百花齐放，太多了，那么该选择什么样的程序设计语言？这有待研究。对于程序设计语言，目前比较流行的主流的就是 C++、java 等等之类的语言。这些语言目前是应用的最为广泛的语言，看过最新一期的程序员杂志就可以知道，C++和 java 是目前应用的人数最多的语言，那么选择什么语言其实就选择了以后发展的方向，你到底是用来创建一些企业的应用程序还是一些普通的信息应用程序？选择的语言它可能有它自己的一些特 色，不同的语言可能使用的场合有点不一样，因此选择程序设计语言这一点必须要慎重。能力毕竟是有限的，选择一种作为你发展的方向，其余的一些设计语言可以 触类旁通。因此选择的方向问题是必须要考虑的一个问题。

3. 脚踏实地，不可快餐式学习

选择好了某一种程序设计语言之后，就要用心钻研下去，心无旁骛，如果是一出现一种新的语言，你就放弃以前的去学习那个新的语言的话，这样是不好的，其实任何一种语言，只要你能好好钻研 10 年的话，对自己有 很大的帮助，这样学习其他的语言的话想对来说很简单。所以第三点的话就是一定要脚踏实地，快餐式地学习是不可取的，幻想遇到机遇，一下子成为高手是很艰难的。学习程序设计语言软件开发的话必须要脚踏实地，一步一步来，遵照他自己的发展规律来从头开始。有的人在学 C++的时候，一开始就直接用编程工具开始编 程序，等要深入下去的似乎却发现很困难。所以在开始的时候要先进行深入的了解才能进行更深一步的学习，否则的话无从谈起。学 java 也是一样，所以要脚踏 实地，一步一步来，循序渐进地去学习。学 java 语言，它有它自己的一些规律，有学习它的途径，通过这个途径可能收效比较慢。但是，可以认为它是一种正规 的学习途径。要从 java 语言本身着手，而不能一上来就用一些软件盲目编写。要先深入了解 java 语言，再用工具。工具固然很重要，但是语言才是其本质。

4. 从做中学

学习编程的关键是要能够动手去做，动手去实现，而不是夸夸其谈。动手去做可以发现更多的一些细节的问题。如果你从事的是讲师或者其他的 一些职业，那么可能动手少一点，但是对于从事软件开发，从事编程的人则要关注更多的细节，而这些细节不是在看书的时候就能发现的。而是在动手实践的时候， 在编代码的时候才能发现一些细节的问题。

5. 多参考程序代码

我们编程最后生成的成果就是程序代码，一个程序员生成的结果也是程序代码，那么别人所编写出来的这些代码，我们去参考的话其实可以更快捷地学习别 人的思想，包括编程思想以及设计思想，因此我们学习编程的一个途径或者是一个捷径就是多多参考别人的程序代码，就这一点来说，实际当中，我们可以参考的资 料，比如一些电子书附带的源代码，可以直接到出版社里面把它的书的源代码下载下来，去研究它，这时候你不看书去研究它的代码也能够对你有所提高，而且是一 种快速的ᨀ高方式，那么另外一个方面，现在有众多的一些开源的框架、一些工具，这些工具的源代码开发，我们可以参考它的源代码，去学习它的设计思想。

6. 加强英文阅读能力

英语阅读能力，对于一个专业技术人员来讲很重要，因为我们现在使用的大部分工具和服务器，它的帮助文档以及指南都是 属于英文的，包括一些最新的技术中文文档也许还没有，所以大多数也都是英文的，这时候需要去了解英文。英文阅读的培养可以很简单，像 java 里面可以去查 询 doc 文档，doc文档本身是英文的，没有中文的。看多了，一些专业词汇慢慢地就可以融会贯通了，对于这些专业词汇来讲，其实词汇量并不是很大，稍微锻 炼一下，慢慢地能看懂了。它不像英文的一些文章或者小说一样充满了华丽的词汇。理解起来相对容易一些，相对简单一些。这就是我们在使用 java 的时候来查 看它的一些帮助文档。任何一种新的工具，新的技术出来的时候，它的文档基本都是英文的。所以必须要加强自己的英文阅读能力。

7. 求人不如求己

第七点就是求人不如求自己，这一点是深有体会的，现在学习 java 想加入到软件编程领域的人一般都是想急于求成，很浮躁，巴不得有什么绝招，三两下搞定， 两三个月马上搞定一份工作，这个其实是很艰难的，这种浮躁的心理在学习编程语言的过程中也会体现出来，一碰到问题，也不去思考，不去自己想办法就去请教别 人，在一个软件公司，如果随便一个小问题就去请教别人的话，一是会被别人看不起，他认为你的能力不行，另一个就是丧失了自己独立思考的能力，不会去想着自 己去解决问题，即使这个问题别人告诉你了，等再碰到一些小的问题的时候，还是不能自己独立去解决，所以求人不入求自己这一点是很重要的，首先你 应该自己去研究，自己去查究，去参考源代码，自己编码试试看，在实在万不得已的时候再去请教别人。

8.	 多读好书

一本好书的定义就是适合自己的书，开始学习的时候一般都是先选择一本薄薄的书，快速地把这本书看完，这本书虽然讲的不是很深入也 不是很完善，但是写的比较简单，也比较薄，很快就看完了，一个是能给自己成就感，再一个就是让自己少遇点挫折，假如一开始就看 java 编程思想，这本书是 好书，但是一开始就看这笨书的话，看不了一个礼拜马上就知难而退了。选一本简单的，入门的书，看完以后再看一本大诠释的书用来做参考，读完入门的书后就该 自己去实践，去做一些小东西，碰到问题的时候就去查那本大诠释的书。这是一个学习的步骤，不能在一开始就去看一本很厚很难的书，这样对学习没有太多的帮 助。不能说捧着一本厚的书就能说自己是 java 大牛。学习的顺序是至关重要的。

9.	 使用合适的工具

对于工具的使用，任何人都不可否认，实际应用开发中要完成的任务都要生成文档，需要建模等等的一些内容，这些内容我们都需 要一些相应的工具来帮助我们快速地进行，选对工具可以大幅度地提高我们的效率，因此使用合适的工具也是一个很重要的要点，不能忽视了这些要点。上面提到的就是我们学习程序设计的时候的一些学习要点。不仅仅是使用在 java 语言的学习当中，无论学习什么语言，这些都是一些共同的要点。



### 二、**JAVA** **学习路径**

1. 基础语法及 JAVA 原理

基础语法和 JAVA 原理是地基，地基不牢靠，犹如沙地上建摩天大厦，是相当危险的。学习 JAVA 也是如此，必须要有扎实的基础，你才能在 J2EE、J2ME 领域游刃有余。参加 SCJP（SUN 公司认证的 JAVA 程序员）考试不失为一个好方法，原因之一是为了对得起你交的 1200 大洋考试费，你会更努力学习，原因之二是 SCJP 考试能够让你把基础打得很牢靠，它要求你跟 JDK 一样熟悉 JAVA 基础知识；但是你千万不要认为考过了 SCJP 就有多了不起，就能够获得软件公司的青睐，就能够获取高薪，这样的想法也是很危险的。获得"真正"的 SCJP 只能证明你的基础还过得去，但离实际开发还有很长的一段路要走。

2. OO 思想的领悟

掌握了基础语法和 JAVA 程序运行原理后，我们就可以用 JAVA 语言实现面向对象的思想了。面向对象，是一种方法学;是独立于语言之外的编程思想; 是 CBD 基于组件开发的基础;属于强势技术之一。当以后因工作需要转到别的面向对象语言的时候，你会感到特别的熟悉亲切，学起来像喝凉水这么简单。使用面向对象的思想进行开发的基本过程是：

1) 调查收集需求。

2) 建立用例模型。

3) 从用例模型中识别分析类及类与类之间的静态动态关系，从而建立分析模型。

4) 细化分析模型到设计模型。

5) 用具体的技术去实现。

6) 测试、部署、总结。

3. 基本 API 的学习

进行软件开发的时候，并不是什么功能都需要我们去实现，也就是经典名言所说的"不需要重新发明轮子"。我们可以利用现成的类、组件、框架来搭建我们的应用，如 SUN 公司编写好了众多类实现一些底层功能，以及我们下载过来的JAR文件中包含的类,我们可以调用类中的方法来完成某些功能或继承它。那么这些类中究竟ᨀ供了哪些方法给我们使用？方法的参数个数及类型是？类的构造器需不需要参数？总不可能 SUN 公司的工程师打国际长途甚至飘洋过海来告诉你他编写的类该如何使用吧。他们只能提供文档给我们查看。基本 API 指的是实现了一些底层功能的类，通用性较强的 API，如字符串处理/输入输出等等。我们又把它成为类库。熟悉 API 的方法一是多查JAVA	DOC 文档，二是使用 JBuilder/Eclipse 等 IDE 的代码提示功能。

4. 特定 API 的学习

JAVA 介入的领域很广泛，不同的领域有不同的 API，没有人熟悉所有的API，对一般人而言只是熟悉工作中要用到的 API。如果你做界面开发，那么你需要学习 Swing/AWT/SWT 等 API；如果你进行网络游戏开发，你需要深入了解网络 API/多媒体 API/2D3D 等；如果你做 WEB 开发，就需要熟悉 Servlet等 API 啦。总之，需要根据工作的需要或你的兴趣发展方向去选择学习特定的 API。

5. 开发工具的用法

在学习基础语法与基本的面向对象概念时，从锻炼语言熟练程度的角度考虑，我们推荐使用的工具是 Editplus/JCreator+JDK,这时候不要急于上手JBuilder/Eclipse 等集成开发环境，以免过于关注 IDE 的强大功能而分散对 JAVA技术本身的注意力。过了这一阶段你就可以开始熟悉 IDE 了。程序员日常工作包括很多活动，编辑、编译及构建、调试、单元测试、版本控制、维持模型与代码同步、文档的更新等等，几乎每一项活动都有专门的工具，如果独立使用这些工具的话，你将会很痛苦，你需要在堆满工具的任务栏上不断的切换，效率很低下，也很容易出错。在 JBuilder、Eclipse等 IDE 中已经自动集成编辑器、编译器、调试器、单元测试工具 JUnit、自动构建工具 ANT、版本控制工具 CVS、DOC 文档生成与更新等等，甚至可以把UML 建模工具也集成进去，又ᨀ供了丰富的向导帮助生成框架代码，让我们的开发变得更轻松。应该说 IDE 发展的趋势就是集成软件开发中要用到的几乎所有工具。

从开发效率的角度考虑，使用 IDE 是必经之路，也是从一个学生到一个职业程序员转变的里程碑。JAVA 开发使用的 IDE 主要有 Eclipse、JBuilder、JDeveloper、NetBeans 等几种；而 Eclipse、JBuilder 占有的市场份额是最大的。JBuilder 在近几年来一直是 JAVA 集成开发环境中的霸主，它是由备受程序员尊敬的 Borland 公司开发，在硝烟弥漫的 JAVA	IDE大战中,以其快速的版本更新击败 IBM 的 Visual	Age	for	JAVA 等而成就一番伟业。IBM 在 Visual	Age	for	JAVA 上已经无利可图之下，干脆将之贡献给开源社区，成为 Eclipse 的前身，真所谓"柳暗花明又一村"。浴火重生的 Eclipse 以其开放式的插件扩展机制、免费开源获得广大程序员（包括几乎所有的骨灰级程序员）的青睐，极具发展潜力。

6. 学习软件工程

对小型项目而言，你可能认为软件工程没太大的必要。随着项目的复杂性越来越高，软件工程的必要性才会体现出来。参见"软件开发学习路线"小节。

**Java** **程序语言的学习要点**

这几个要点，无论是哪个 java 开发人员都要了解

1. 就是要勤查 API 文档

这是程序员与程序员交流用的文档，因此这些文档很重要，其实也 是一些工具生成的文档，应该对其引起足够的重视；

2. 遇到问题时如何解决？

   查书-》写代码测试-》查看源代码-》请教别人遇到问题的时候，一般都尽力去查找相关的书籍看有没有相关的解决方案，也可以到 google 里面去搜索相关的文档，然后写代码来测试，如果这样还不能解决问题的话就需要去查找源代码。查看源代码对方法是如何去实现的，了解这些源代码 之后就对这些 API 有了深层次的了解，这样在实际的应用中就可以通过查看源代码来解决问题，实在万不得已再去请教别人；

3. 学习开源软件的编程思想

   等到达一定的层次之后就可以去查找一些开源软件的源代码，查看这些开源软件的编程思想，学习设计模式，了解这些设计思想之后就可 以应用到时间当中了，一些开源的软件的源代码都是开放的，下载一些软件的时候就把源代码一起下载，然后研究这些源代码，如果理解了这些源代码，那么软件的 使用也就会了。通过学习这些源代码就能学到一些大师们的精髓思想。

   

# 主题2：**我们的第一个** **Java** **程序**

## 一、**内容提要**

前面我们学习了一个程序员是如何思考问题，如何学习 Java，以及 Java的工作原理。在这个主题中，我们将要学会配置 Java 开发环境，动手编辑我们的第一个 Java 程序。并且学会如何开发 Java 程序的三个步骤：编辑源程序，编译和运行 Java 程序。

## 二、**学习目标**

学完本模块以后，你应该能够

·解释 JDK 的组成和作用，解释 Java 源程序的基本结构

·下载 JDK，并在计算机上配置好开发环境

· 编写一个简单的 Java 程序输出一行文字，并编译和运行该程序

## 三、**重点难点**

· Java 环境变量的配置

·Java 应用程序的编译和运行

· Java 应用程序基本结构

## 四、**学习内容**

模块 1	安装和配置 JDK（建议学习时间：60 分钟）JDK 的基本知识，如何安装 JDK 并配置 Java 环境变量										

模块 2	我们的第一个 Java 程序（建议学习时间：30 分钟） 编写、编译并运行一个简单的 Java 应用程序

模块 3	 解剖我们的第一个 Java 程序（选学：30 分钟）分析模块 2 中的 Java程序范例，了解 Java 源程序的基本结构

模块 4	 使用 Windoows 命令行界面（选学：30 分钟）学习使用 Windows 命令行程序的基本命令

## **模块** **1** **安装和配置** **Java** **开发环境**

 为方便开发，Java 的发明者 Sun 公司ᨀ供了一个免费的用于编写 Java 程序的工具—Java 开发工具包：JDK（Java Development Kit）。

 JDK 是一组用于创建、编译和运行 Java 程序的**命令行程序**。每发布一个Java 新版本，Sun 都ᨀ供了一个新的开发工具包，截止到 2008 年 6 月，最新的版本为 Java 6，即 JDK 第 6 版。

 在本课程中，我们使用JDK加上Windows自带的文本编辑器作为开发环境。虽然市面上有更高级的 Java 编程工具，如 Ecplips、NetBean、IntelliJ IDEA等，但是对于初学者来说直接使用 JDK 开发能够帮助初学者掌握 Java 的基本工作原理，而且 JDK 对计算机的性能要求很低。

 本模块介绍如何下载、安装和设置 JDK 以及如何使用它来创建、编译和运行一个简单的 Java 程序。此外，还将针对 Java 初学者，介绍如何正确配置JDK。

### **JDK**

在前面的主题 2 中，我们学习了 Java 的工作原理。开发 Java 程序，不仅需要解释器，还需要用于创建、运行和测试程序的编译器和其他工具。JDK 是整个 Java 的核心，包括了 Java 运行环境（Java Runtime Envirnment），一堆 Java 工具和 Java 基础的类库(rt.jar)。不论什么 Java应用实质都是使用某个版本的 JDK 开发的。因此掌握 JDK 是学好 Java 的第一步。最主流的 JDK 是 Sun 公司发布的 JDK，除了 Sun 之外，还有很多公司和组织都开发了自己的 JDK，例如 IBM 公司开发的 JDK，BEA 公司的 Jrocket，还有GNU 组织开发的 JDK 等等，它们在某些平台上的运行效率甚至超过了 Sun 的JDK。JDK 提供了编译器、解释器、调试器、文件打包程序等工具。和集成开发工具（IDE）相比，JDK 比较简单原始，没有ᨀ供图形用户界面、文本编辑器以及其他一些程序员需要使用特性。

 要使用 JDK，请在命令行窗口（Linux 和 Unix 中称为终端）中执行命令。MS－DOS、Linux 和 UNIX 用户应熟悉这种命令方式。

 目前最新的 JDK 版本为 JDK	6，可用于 Windows 操作系统：包括 Windows98/Me/NT（带 Service	 Pack	 4）/2000/XP/Server	 2003/Vista；Linux 操作系统以及 Solaris 操作系统。按照 SUN 公司对安装 JDK 的系统硬件要求，2000 年后的计算机基本都可以安装 JDK。

```
【Java 小博士】
问：什么是 JRE？
答：Java 运行环境，通常已经包含在 JDK 中了。如果我们只是为了运行程序，而非从事 Java 开发的话可以直接下载 JRE，在我们的系统上安装。JRE 可以在sun 公司的网站，或是 java.com 上面下载。
问：我听说还有 J2EE 的和 J2ME 技术，他们和 JDK 是什么关系？
答：SUN 公司提供的 Java 开发包有三类：
JDK：Java 开发平台标准版，适合 java 小程序或普通 java 程序，java 桌面程序的开发。
J2EE：Java 开发平台企业版，应用于企业级的开发，很多大型应用基于j2ee 技术，如电子商务网站，企业的信息管理系统等。
J2ME：Java 开发平台移动版，用于手持设备（手机，pda 等）应用程序的开发。我们常见的手机游戏，以及手机应用程序如读书软件，股票软件等很多都是用 j2me 技术开发的。
```

![image-20220717155158928](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717155158928.png)

### **获得** **JDK**

安装 JDK 的第一步是获取 JDK 安装程序，我们可以通过下面三种方式中的任一种获得：

·从网络学院发放的课程光盘上获得（光盘目录 XXXX） 

·从网络学院的服务器上下载（网址：XXXXX） 

·从 SUN 公司的网站上或其它网站下载

前面两种方式都很简单，下面我们介绍第三种：如何从 SUN 公司的网站上下载 JDK。主要的步骤分为 3 步。

1. 用浏览器打开 http://java.sun.com/javase/downloads/index.jsp **进入****JDK 下载页面**。在网站的下载（Download）区ᨀ供了到多个 JDK 版本的链接，还ᨀ供了整合 NetBeans 开发环境的 JDK，以及其他与 Java 相关的产品。此处，我们应下载的产品是 JDK X 软件开发工具包（X 代表某个数字，也有可能是 JDKX UpdateX）。

   ![image-20220717155327446](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717155327446.png)

   点击 Download（下载）按钮，进入下一个页面

![image-20220717155354303](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717155354303.png)

2. **根据您的操作系统选择合适的安装程序包**。在 Platform（操作系统平台）中选择 Windows，Language（语言版本）选择“Multi-langugae”（多语言），并勾上“I agree“（同意），然后点击“continue”按钮继续。

3. **下载安装程序**。我们可以有两种选择，脱机安装和在线安装。脱机安装程序会包含安装 JDK 所需要的所有文件，安装的时候不需要联网，可以在多台计算机上安装，缺点是需要下载的文件很大。在线安装程序将需要安装的文件放在互联网上，根据我们的需要（操作系统和我们的安装选择）将所需要的文件下载到本地安装，缺点是安装的时候需要联网，而且在不同的计算机上安装需要重复下载安装内容。根据我们的需要选择安装方式。点击选项下面的链接下载。

   ![image-20220717155456105](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717155456105.png)

   在此我们选择脱机安装的安装程序包，选择 Windows Offline Installation 下载该文件后，便可以开始安装 JDK 了。

   ### **安装** **JDK**

   安装 JDK 前，首先确认系统中没有安装其他 Java 开发工具，安装多个 Java开发工具常常会导致 JDK 出现配置方面的问题。我们可以到控制面板的安装/卸载工具中，查看是否已经安装了其他版本的 JDK，如果有则双击已安装的JDK，选择卸载。

   

   由于 JDK 的版本经常升级，安装过程的步骤和自定义选项可能和本课程中的介绍有差异，如果您安装所有默认选项的话，只要一直点击“同意”或“下一步”即可。如果您装有反病毒软件的话，安装程序可能被拦截，此时应该允许安装程序对系统的更改。

   下面是我们以 JDK6 Update6 为例介绍 JDK 的安装步骤：

   1. 双击安装文件，安装向导将引导我们完成软件安装过程。如果接受 Sun 提出的使用该软件的条款和要求，将被询问要将程序安装到哪里

      ![image-20220717155628364](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717155628364.png)

      图 1 选择 JDK 的安装文件夹

      2. 向导默认了一个安装文件夹。一般来说，默认的文件夹为 C:\Program Files\Java\jdk*XXX*\（*XXX* 和 JDK 的版本号有关，如 JDK6 的目录为C:\Program Files\Java\jdk1.6.0\。安装 JDK 时，默认的文件夹和操作系统的参数配置有关，可能与此不同）。如果要选择安装到其他文件夹，可以单击“更改”按钮，然后选择或新建一个文件夹，并单击 Ok 按钮。向导将返回“自定义安装”对话框。

      在这个界面，安装程序还可能询问要安装 JDK 中的哪些内容。默认的情况下，向导将安装所有的 JDK 组件。按照默认设置安装 JDK 需要大约 150MB的可用硬盘空间。如果我们的硬盘空间紧张，可以不安装除开发工具外的其他项，以节省硬盘空间。对于不想安装的组件，可单击它旁边的硬盘图标，然后选中选项“不安装此功能”。选择完自定义安装项目后，点击“下一步”继续。

      | **组件名称**   | **内容**                                                     | **是否必须安装**                                             |
      | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
      | 开发工具       | 创建 Java 软件所需的可执行程序                               | 必须要安装                                                   |
      | 演示程序及样例 | 我们可以运行的 Java 2 程序及其源程序，可以通过查看这些源程序来更深入地了解 Java。 | 本课程不需要该部分，如果我们想看看 Java 范例程序的源程序，可以 |
      | 源程序         | Java 2 类库中成千上万个类的源程序                            | 本课程不需要源程序，如果我们想看看 Java 程序的源程序，可以选择安装 |
      | 公共 JRE       | 一个 Java 解释器，可以将其随程序一起分发                     | 建议安装                                                     |
      | JavaDB         | Java 数据库                                                  | 本课程不需要，可以不安装                                     |

      3. 安装向导继续运行安装 JRE，会进入“Java 安装-自定义”窗口，此处可以采用安装程序的默认设置，直接点击“下一步”按钮，继续安装进程。直到安装结束，点击“完成”按钮。

         ![image-20220717160217035](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717160217035.png)

         

### **配置环境变量**

安装JDK是构建Java开发环境的第一步。安装完成后，必须编辑计算机的环境变量，以便包含对JDK的引用，这样做的目的是告诉操作系统JDK中的相关工具/程序的位置在哪儿。

配置JDK时，需要设置下面两个变量：**PATH**和**CLASSPATH**。PATH是一个系统变量，当用户运行某个程序时，它帮助计算机查找该程序的位置。该变量记

录了对一系列文件夹的引用，文件夹之间用分号隔开。此处我们要做的是在系统的PATH变量中添加到JDK的bin文件夹的位置（bin文件夹存放了编译器等工具）。如果JDK安装在文件夹C：\Program	Files\Java\jdk1.6.0中，则需要在PATH中添加引用 **C:\ProgramFiles\Java\ jdk1.6.0\bin**。

所有的Java程序都依赖于两种类文件：我们创建的类和Java类库，后者是数百个表示Java语言功能的类。CLASSPATH变量告诉JDK到哪里去查找Java类文件。设置CLASSPATH变量，就是创建或设定该变量，使其包含一个到当前文件夹的引用（句点和分号）以及指向JDK的lib文件夹中的文件tools.jar的位置以及第三方类库的位置（如果需要的话）。如果JDK安装在文件夹C:\ProgramFiles\Java\jdk1.6.0中，则需要设定CLASSPATH为 **.;C:\ProgramFiles\Java\jdk1.6.0\lib\tools.jar**。

下面将详细介绍如何在 Windows 系统上设置 PATH 和 CLASSPATH 变量。

### **配置** **PATH** **变量**

在 Windows NT/2000/XP 中，变量 PATH 是通过“环境变量”对话框（“控制面板”功能之一）来配置的，下面是配置 PATH 变量的步骤。

1. 在桌面上的“我的电脑”图标上单击鼠标右键，然后选择“属性”选项，打开“系统属性”对话框；或单击“开始”按钮，在控制面板中打开“系

统”对话框。

2. 单击“高级”标签；

3. 单击“环境变量”按钮，打开“环境变量”对话框

4. 选择“系统变量”列表框中的PATH，然后单击“编辑”按钮（如果没有就点击新建创建一个）。这将打开“编辑系统变量”对话框，其中的“变量名”文本框中的内容为PATH，而文本框“变量值”中是一系列的文件夹。要将文件夹添加到PATH变量中，单击文本框“变量值”，并将**光标移到末尾**。然后，添加**一个分号**和我们电脑中**JDK****的****bin****文件夹**的路径。如

   ```
   ;c:\Program Files\Java\jdk1.6.0\bin
   ```

   修改后，单击“确定”关闭对话框“编辑系统变量”，再关闭对话框“系统变量”。

### **配置** **CLASSPATH** **变量**

在 Windows 操作系统中，也可以使用“环境变量”对话框来配置 CLASSPATH变量。步骤如下：

1. 在桌面上的“我的电脑”图标上单击鼠标右键，然后选择“属性”选项，打开“系统属性”对话框；或单击“开始”按钮，在控制面板中打开“系

统”对话框；

2. 单击“高级”标签；

3. 单击“环境变量”按钮，打开“环境变量”对话框；

4. 如果系统中没有 CLASSPATH变量，则单击“系统变量”列表框下面的“新建”按钮，打开“新建系统变量”对话框。在“变量名”文本框中

输入 CLASSPATH，并在文本框“变量值”中输入CLASSPATH 的正确值。如果系统中已经有一个CLASSPATH 变量，则选中它，然后单击“编辑”按钮，打开“编辑系统变量”对话框。CLASSPATH 必须至少包含两项内容：**到当前文件夹的引用（.）和到 Java类库所属文件（tools.jar）的引用**，这两项间要用分号隔开。

![image-20220717162455885](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717162455885.png)

5. 设置好 CLASSPATH 后，关闭对话框“编辑系统变量”或“新建系统变量”，再关闭“环境变量”对话框。

   配置完环境变量后，应运行 Java 解释器，看它能否正常工作。为此，打开命令行窗口，输入命令：

```
java -version
```

其中，Java 是 Java 解释器的名称,*version* 是一个参数，命令解释器显示其版本号。

![image-20220717162631660](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717162631660.png)

```
【Java 小博士】
问：Java 的版本号是如何定义的？
答： 当我们查看该产品时，可能发现 JDK 的版本号有两个数字组成，如JDK 6 Update6。为修复错误和安全方面的问题，Sun 定期发布新的 JDK 版本，并通过在主版本号后面加上句点和数字来对其进行编号。请选择最新的 JDK 6 版本。为了某种营销的原因，Sun 把 Java1.6 改称为 Java6，但是开发工具的版本号还是 1.6，其实它们都是同样的东西。

问：JDK 安装完成以后，在安装目录下会生成的目录，它们都是何用途？
答：以 jdk1.6 为例，默认情况下，安装完以后在安装的路径下会生成下面的文件和子目录。其中在 bin 文件夹下主要是 jdk ᨀ供的一些工具程序，如 javac，javadoc 等，lib 文件夹下主要是库文件，包括 jdk 的 API 类库；jre 文件夹下 java 的运行时环境；demo 目录下是一些程序范例。
```

![image-20220717170109058](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717170109058.png)

## **模块** **2** **我们的第一个** **Java** **程序**

本模块将向您介绍最简单的 Java 程序。麻雀虽小，五脏俱全。这个程序虽然简单，但是它却包含了编写 Java 程序所需要的各个部分，我们通过这个程序就可以了解 Java 程序的基本概念。

### **选择源程序编辑器**

编辑器是用来创建和编辑源程序的应用软件。虽然 JDK 中没有提供，但是任何能够保存无格式的文本文件的编辑器或字处理器都作为 JDK 的编辑器。在使用这些编辑器保存文档或设置文档的属性时，请务必将程序保存为纯文本格式。

在本课程中我们使用 Windows 自带的“记事本”软件编写 Java 源程序。

记事本是 Windows 操作系统自带的一个简单文本编辑器，只能处理纯文本文件，不能同时处理多个文档。要在 Windows 中运行“记事本”，可单击“开始”按钮，然后选择“所有程序／附件／记事本”。

### **创建第一个** **Java** **程序**

下面我们将创建我们的第一个Java程序。在这个程序中我们将通过该程序操纵计算机在屏幕上输出一句话：“Hello	world！”（意思为“你好，世界！”）主要分为四步，如下：

![image-20220717170507559](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717170507559.png)

**○**

**1** **输入程序代码****EasyJava.java**

```
【动手做】
1. 打开命令行窗口，输入下面两行命令，在我们计算机的C盘根目录下新建一个文件夹javaproj用于存放java源程序文件（您也可以自由
指定您保存的文件夹名和位置）。
cd	c:\
md	javaproj

2. 运行记事本软件，输入下面程序清单中的Java程序代码，核对代码和程序清单完全一致。

3. 点击记事本程序菜单中的文件/保存，在弹出窗口中选择我们的工作文件夹（如C:\javaproj）；选择保存类型为“所有文件”，在文件名中填写EasyJava.java；点击保存按钮，保存源程序。
```

```
public class EasyJava {
 public static void main(String[] args){
System.out.println("Hello world!");
 }
 }
```

在录入上面代码的时候，需要注意：

· 正确地输入其中的圆括号、花括号和引号，同时确保大小写完全与该程序清单相同。使用空格或TAB键在某些行的行首插入空格。



· Java源程序的扩展名必须为java。在默认情况下“记事本”会在我们保存的Java源程序文件名后自动加上扩展名txt，存为文本文件。例如，

EasyJava.java可能会被保存为EasyJava.java.txt,为避免这种错误，请先在文件类型选项中选择“所有文件”再保存。



·源文件名EasyJava.java和源程序第一行的类名EasyJava必须大小写完全一致。如果不一致，则可能编译时会出错。

### **编译** **Java** **源程序**

Java 是一种编译执行的语言，必须先编译才能运行。编译程序的用处是将我们向计算机发出的指令转换为计算机能够理解的格式，同时尽可能地提高程序运行的效率。在 JDK 中我们使用 Java 编译器（javac.exe）对源程序进行编译。

Java 编译器将 Java 程序源程序转换为一个或多个由字节码组成的类文件，这些文件可以被 Java 解释器执行。在进行编译的时候，Java 编译器读取扩展名为“.Java”的源程序文件，并创建一个或多个可被 Java 解释器运行的“.class”文件。

**2** 、3** **编译刚才创建的** **EasyJava.java**

```
【动手做】
打开命令行窗口，切换到 EasyJava.java 所在的文件夹，
 cd	c:\javaproj
 输入下述命令来编译 java 源程序：
```

![image-20220717170844484](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717170844484.png)

上述命令使用 JDK 编译器编译名为 EasyJava.java 的 Java 源程序。该命令由两个元素组成：JDK 编译器(Javac.exe)和要编译的程序的名称（EasyJava.java），它们之间用空格隔开。

通常情况下，如果程序通过编译，JDK 编译器将不会显示任何消息；在这里“没有消息就是好消息”。**对** **Java** **源程序的编译创建了一个名为**

**EasyJava.class** **的类文件**，它位于 EasyJava.java 所在的文件夹中。

![image-20220717170913520](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717170913520.png)

如果程序有错误，编译器将指出错误以及导致错误的代码行（如下图）。这时候请回到步骤·1 查看和修改源程序文件，确保输入的内容与程序清单EasyJava.java 完全相同。再重新编译修改后的源程序直到成功。

![image-20220717171023248](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717171023248.png)

### **运行** **Java** **程序**

有了 Java 类文件后，可以使用 Java 解释器来运行它。解释器用于从命令行运行 Java 应用程序，让计算机理解程序中的指令，并按照指令要求完成任务。JDK 中的解释器名为 Java.exe，它也是从命令行运行的，同 **Javac** 命令类似。

**4 运行程序 EasyJava**

![image-20220717171150853](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717171150853.png)

![image-20220717171202666](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717171202666.png)

运行结果如上图，将看到计算机返回一行语句“Hello	world！”。如果能够成功地编译和运行该程序，说明 JDK 能正常工作，可以开始学习本课程的下一个单元。如果即使程序中的代码与书中完全相同，程序仍然无法通过编译，问题可能是 JDK 的配置不正确，请按照上面配置环境变量的方法，检查并重新配置环境变量 PATH 和 CLASSPATH。

在使用 Java 解释器的时候要注意：

· 虽然 Java 类文件的扩展名为 class，但使用解释器时一定不能指出扩展名“.class”。 

· 如果一个源文件中有一个类被声明为 public（一个源文件中最多只能有一个类被声明为 public），那么程序名和这个类的类名完全一致，包括大小写。如果不一致就会发生错误，不能正常执行程序。

![image-20220717171307607](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717171307607.png)

参考答案：

此处的错误提示是：无类定义错误。有可能是要求运行的 Java 类和类定义不一致，一般是因为错误拼写类名，此处将类名错误拼写为“easyjava”，就会发生错误，正确的拼法应该是“EasyJava”，注意大小写。还有种情况就是 CLASSPATH 变量配置错误，漏掉了句点，找不到本地的类文件，当然也就没有可运行的类。

```
【ᨀ问问答】
问：为什么我们要在第一个程序中打印 HelloWorld？
答：“hello	world”是英文“您好世界”的意思，通过计算机向世界问好是计算机编程领域的一个传统，一般程序员试验新程序语言或技术框架的时候都创建一个简单的程序打印“Hello world！”，来试验是否可以正常使用这种语言或技术。

问：为什么我们要在 Java 程序的每行前插入一些空格？
答：我们编写 EasyJava 程序时，可能没有使用空格或 TAB 键缩进，但它也能成功编译。虽然每行开头的空格数不重要，但在 Java 程序中应采用一致的缩进方式。空格有助于查看程序的组织结构以及语句所属的程序块。开始编写复杂的程序时，将发现不使用空格会很困难。这些空格对编译器是无意义的，编译器在编译源程序时会自动忽略这些空格。

问：我的计算机系统有多个字处理程序，应使用哪个来编写 Java 程序？ 
答：任何能够将文件保存为纯文本格式的字处理程序都可以。除记事本程序外 Windows 用户还可以使用写字板或 Microsoft Word 等编辑器，但必须将文件保存为文本格式，而不是其它专用格式；UNIX 和 Linux 用户可以使用 emacs、pico 或 VI 来编写程序；Macintosh 可使用 SimpleText 或前面提到的 Unix 工具来编写 Java 源程序文件。由于 Javac 编译器在错误消息中列出行号，因此具有行号显示功能的编辑器有助于更快地调试程序。例如 Windows 程序员使用的编辑器 UltraEdit－32 在窗口底部显示行号和列号。

问：我在编译器指出有错误的行中没有发现任何错误，我能做些什么？ 
答：错误消息中显示的行号并不总是程序中发生错误的地方。检查错误消息指出的行号上面的行，看看能否找到拼写错误或其他错误。错误通常位
于相同的程序块中。

问：Java 源文件在运行 Java 程序的时候是必须的么？
答：Java 类文件中包含将被 Java 解释器执行的 Java 字节码。在发布 Java程序的时候，可以不发布 Java 源程序，只发布编译过的 Java 类，或是 Java类组成的包。
```

## **模块** **3** **解剖我们的第一个** **Java** **程序**

在本模块中，我们将以前面模块中的 EasyJava.java 程序作为实例，讲解Java 源程序的基本结构。本模块中的相关内容只是让大家了解一下 Java 程序的基本结构，相关的知识在第二单元和第三单元学习。

### **什么是源程序文件？**

源程序文件是带有类定义的文件，扩展名为.java。类是程序的基本零件，小程序或许只用到一个类（如EasyJava.java），大程序需要几十上百个类协同工作。

类又是由方法和语句组成的。源程序、类、方法和语句的关系是：

·类存在于源文件中，一个源文件可以包含一个或多个类；

·方法存在于类中，一个类可以包含零个一个或多个方法；

· 语句存在于方法中或类中。

![image-20220717172255392](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717172255392.png)

### **什么是类？**

类是一组方法和属性的集合，Java 中所有的东西都会属于某个类，类中带有一个或多个方法，方法必须在类的内部声明。

![image-20220717172346168](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717172346168.png)

上面的代码（黑体加粗部分）告诉计算机，将 Java 程序命名为 EasyJava。术语 Class 的含义是类，public 表示这个类是公开可见的，即可以被别的类看见和使用。

在第一行的末端有一个大括号，和程序结尾的大括号为一组。在 java 程序中，大括号内的内容属于一个**语句块**。语句块以 “{”为开始标志， “}” 为结束标志，表达了语句的作用范围，块中的内容当作一个整体来执行。语句块可以嵌套语句块。此处，EasyJava 后的语句块表明是 EasyJava 类的内容。

### **什么是方法？**

**方法**是一组语句的集合，是一组相关的操作计算机的指令，目的是通过系列的操作完成一项任务。

![image-20220717173546756](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717173546756.png)

这行代码告诉计算机，程序的主要部分从这里开始，此处声明了一个 main方法，它的参数是字符串数组 args，用于接收向 main 方法输入的内容。此处main 方法有三个修饰符，用于界定 main 方法的特征。

· public 表示这个方法是公共可见的；

· static 表明这是一个静态方法，不需要实例化就可以执行；

l void 表明这个方法只执行某些指令，不向程序其它部分返回数据。

上面的这三个修饰符是 main 方法的必须具有的，不管你的程序内容如何，你的 main 方法都必须这么写。

在 Java 程序中，main 方法是程序的起点，不管我们的程序有多大，不管有多少个类，都从某一个 main 方法来作为程序的起点。

### **什么是语句？**

每一条语句就是一个指令，Java 语句以分号结尾，可以跨行。

![image-20220717173808091](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717173808091.png)

此处指令的意思是要求计算机向标准输出打印一串字符“Hello	world！”。

System.out.println 是 Java ᨀ供的基本命令（库函数），具有打印一行字符并回车功能。

### **EasyJava** **程序翻译**

根据前面对 EasyJava 程序的剖析，我们可以将这个程序翻译成我们可以看懂的自然语言，如下

```
public class EasyJava {
 public static void main(String[] args){
System.out.println("Hello world!");
 } 
 }
```

```
类 EasyJava 从这里开始
			 类 EasyJava 的 main 方法从这里开始
					 向终端打印一个字符串“Hello	world！”
			 main 方法结束
类 EasyJava 到这里结束
```

现在你该明白 EasyJava 程序是怎样构成的了吧 ： 

### **Java** **的注释和编码风格**

**注释**是源程序中用以解释源程序代码的说明性文字。注释是写给程序的阅读者看到，而不是给机器的指令，编译器在编译时会自动略去。Java 提供了两种注解风格，一种是传统风格，以/*开头，后面的注释内容可以跨多行，最

后以*/结尾，在此之间的所有内容（包括代码）都将作为注释被编译器忽略。

如下例

```
	 /*	 这是对 Java 源程序的注释
					 这是注释的第二行
					 这是注释的最后一行	 	 */
```

第二种注释方式是单行注释，以//为首，直到本行末尾。这种方式非常方便，因此被广泛使用。

```
//这是简约风格的注释
```

除了上面这两种注释外 Java 语言中还有一种特殊的注释，以/**开头，以*/结尾，这是 Java 中的文档注释，通过这种注释可以利用 javadoc 命令生成 Java文档，这里仅需了解即可。

在 Java 语言中，我们对命名有一些通俗的约定，比如类名的开头要大些，如果类名由多个单词组成，则单词间没有空格，每个单词的首字母大写（如StudentInfomation）。方法的命名也一样，只是开头的字母一定是小写（如getName）。关于编码风格，可以参考相关的资料（XXXXX）

【动手做】

对 EasyJava 程序做点小修改，让它向你问好。

1. 让它打印”你好，XXX”（XXX 是你的名字）

2. 让它在打印一行话“第一单元到此结束。”

   

```
【提问问答】
问：为何在 Java 程序语言中所有的东西都得包含在类中？
答：因为 Java 是面向对象的语言，和其他面向过程的语言不同。类是面向对象编程的基本单位。Java 中绝大多数东西都是对象，所以包含在类中。

问：每个类上都需要加上一个 main 方法么？
答：不需要每个类都有 main 方法，一个程序可能会用到多个类，而只要有某一个类有 main 方法作为程序的入口即可。

问：Java 程序中类的名称和方法的名称有讲究么？
答：在 Java 中有命名规定，符合命名规则的名称就可以正常编译和执行。但是为了方便阅读，我们对命名有一些通俗的约定，比如类名的开头要大些，如果类名由多个单词组成，则单词间没有空格，每个单词的首字母大写（如 StudentInfomation）。方法的命名也一样，只是开头的字母一定是小写（如 getName）。

问：在 Java 程序中，一行语句和一条语句是一回事么？ 
答：不是，虽然大部分的情况下一条语句放在一行内，实际上语句结束的标志是分号（；）而不是行。我们可以将多条语句放在一行，也可以将一条
很长的语句分几行写。我们根据实际情况决定如何分行，目的是为了使人阅读方便。

问：Java 程序被称为一个类和一组类。哪种说法是正确的？ 
答：两者都正确。在接下来几章中，创建的简单 Java 程序将被编译为扩展名为。class 的单个文件，可以使用 Java 解释器来运行它们。Java 程序也可以由一组协同工作的类组成，实际上，即使简单程序（如 EasyJava）在幕后也使用了其他 Java 类（System.out.println）。

问：每个 Java 程序都有 main()方法么？ 
答：当 Java 虚拟机启动的时候，它会寻找我们在命令行中所指定的类，然后寻找这个类的 main 方法，并执行 main 方法中所有的语句。每个 Java 程序都至少会有一个类以及一个 main 方法。每个应用程序只有一个 main 函数。执行某个程序就是命令 Java 虚拟机（JVM）去加载某个类，然后开始执行它的 main 方法，一直运行到 main 的所有代码结束为止。main 方法是程序的起点，不管我们的程序有多大，不管有多少个类，都从某一个 main方法来作为程序的起点。
```

## **模块** **4** **使用** **Windows** **命令行界面****（补充模块）**

命令行提供了通过键盘输入命令（而不是使用鼠标加菜单）以操纵计算机的方式。当前，Windows 程序很少需要使用命令行，但是我们在使用 JDK 的时候还是要使用命令行界面。

### **打开** **MS-DOS** **命令行窗口**

在 Windows 系统中，要切换到命令行，可进行如下操作：

· 对于 Windows 98 和 Me，选择“开始/程序/MS－DOS 方式”；

· 对于 Windows NT/2000，选择“开始/程序/附件/命令提示符”；

· 对于 Windows XP/Server2003，选择“开始/所有程序/附件/命令提示符”。

· 对于 Windows Vista 系统，选择“开始/附件/命令提示符”

选择上述菜单后，将打开一个命令行窗口，可以在其中输入命令。

Windows 命令行使用 MS－DOS（Windows 之前的 Microsoft 操作系统）命令。MS－DOS 支持 Windows 的功能有复制、移动和删除文件和文件夹；运行程序；扫描和修复硬盘；格式化软盘等。

![image-20220717210017407](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717210017407.png)

打开命令行窗口后，在窗口的命令行上将有一个不断闪烁的光标。在图 2中，命令行为 C:\Users\Qing（这是系统的当前路径，随着目录的改变会发生改变）。由于在 MS－DOS 窗口中，可以删除文件甚至格式化硬盘，因此尝试使用其命令前，应对 MS－DOS 操作系统有基本了解。然而，就使用 JDK 而言，只需了解几个 MS-DOS 操作：例如如何创建文件夹、如何切换到文件夹以及如何运行程序，下面我们将分别介绍这几个命令。

### **在** **MS-DOS** **中运行程序**

要从命令行运行程序，最简单的方式是输入可执行文件的名称并按回车键。例如，输入 DIR 并按下回车键，可以查看当前文件夹中的文件和子文件夹。也可以在程序名后加上空格和控制程序如何运行的选项。这些选项被称为参数。命令参数和命令选项都是可选项目。常见命令格式为

![image-20220717210225273](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717210225273.png)

```
【提示】：
CD 命令的是“Change	Directory”的缩写，意为改变目录。
MD 命令是“Make Directory”的缩写，意为创建目录。
RD 命令是“RemoveDirectory”的缩写，意为删除目录。
```

### **相对路径和绝对路径**

每个磁盘上可有多个子目录，**DOS** 利用**路径**来指定各个子目录。所谓**路** **径**，就是从根目录或当前目录到所要找的文件、目录，须经过的全部子目录的顺序组合。各子目录名之间用反斜杠”\”分隔开。

从根目录开始（以“\”开头）的路径称为**绝对路径**，而从当前目录开始的路径称为**相对路径**。

由上述可知，绝对路径是指从 DOS 的根目录下到目标文件目录的路径。相对路径是指从当前目录到目标文件目录的路径。例如目前你所在路径是

C:\ABC\，而你要访问的文件是 C:\ABC\DEF\1.txt,此时

C:\ABC\DEF\1.txt是你的绝对路径，而你的相对路径是\DEF\1.txt

### **在** **MS-DOS** **中切换文件夹**

要在 MS－DOS 中切换到某个文件夹，可执行 CD 命令并指定文件夹名，然后按下回车键，如下例所示：

```
cd C:\javaproj
```

执行上述命令后，将切换到 C 盘的 javaproj 文件夹（如果有这个文件夹的话）。切换到某个文件夹后，命令行的前端将显示为该文件夹的名称。在命令行窗口中切换文件夹。

也可以通过其他方式来使用 CD 命令。见下表

| CD \           | 切换到当前硬盘驱动器的根目录                                 |
| -------------- | ------------------------------------------------------------ |
| CD 子目录名 XX | 切换到当前文件夹中的子文件夹 XX（如果有这样的文件夹）        |
| CD..           | 切换到当前文件夹的父文件夹。*例如，如果当前文件夹为**C:\Windows\Fonts，**则执行命令 CD．．后将切换到文件夹**C:\Windows* |

### **在** **MS-DOS** **中列出文件列表**

在 Windows 系统中使用 MS-DOS 时，可以访问在 Windows 中能够使用的所有文件夹。要列出某个文件夹下的文件及子目录，可使用 Dir 命令，如下例所示：

```
dir C:\javaproj
```

这将显示在 C 盘的根目录下文件夹 STUFF 中的文件及子目录。

如果缺省参数直接键入 Dir 则显示当前文件夹下的文件及子目录。

```
dir
```

### **在** **MS-DOS** **中创建和删除文件夹**

要从命令行创建文件夹，可使用 MD 命令并指定要创建的文件名称，然后按回车键，如下例所示：

```
md C:\STUFF
```

这将在 C 盘的根目录中创建文件夹 STUFF。如果直接键入 md 加上文件夹名称，则在当前文件夹下的创建子文件夹。要切换到新创建的文件夹，可使用 CD 命令和该文件夹的名称要从命令行删除文件夹，可使用 RD 命令并指定要创建的文件来名称，然后按回车键，如下例所示：

```
rd C:\STUFF
```

这将在删除 C 盘的根目录下的文件夹 STUFF。

### **在** **MS-DOS** **中删除文件**

要从命令删除文件，可使用 del 命令并指定要创建的文件名称，然后按回车键，如下例所示：

```
del C:\STUFF\EasyJava.class
```

这将删除位于 C 盘的文件夹 STUFF 中的 EasyJava.class 文件。

### **拷贝文件**

copy 在英文中是复制的意思，所谓复制就是原来的文件并没有任何改变，重新产生了一个内容和原来文件没有任何差别的文件。下面是 copy 命令的格式及该注意的一些问题：

现在让我们来看一个例子，根目录下有一个文件叫做 autoexec.bat，如果我们想将它复制一份叫做 autoexec.old，就可以输 入:copy autoexec.bat  autoexec.old	 键入 dir，除原有的 autoexec.bat文件外，出现了一个 autoexec.old文件，而且这两个文件的大小都一样。

![image-20220717213646253](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717213646253.png)

如果我们想把 dos 目录下的 edit.com 复制到当前目录，就从键盘上敲入:copy c:\dos\edit.com	 （注意，省略了目的目录名和文件名），源文件名是C 盘根目录下 dos 目录中的 edit.com 文件。在这里指出了所在的驱动器及目录，而目的文件被省略了，这表示将文件复制到当前目录中，名字不变，也是edit.com。



如果你想把文件复制到另一个驱动器，比如说复制到 A 盘上，可以输入:copy edit.com a:	 （得记住往 A 驱动器里插磁盘哦）。



copy 命令也可以使用通配符，例如要复制 A 盘上以 K 开头的所有文件，可以输入 copy a:k*.*，如果要复制 C 盘根目录下所有扩展名是 bat 的文件到zht 目录里，可以输入 copy c:\*.bat c:\zht。



```
【提问问答】
问：在 MS－DOS 下，如何重复以前输入过的命令行？
答：在 MS－DOS 命令行窗口中可以使用键盘的上、下箭头在这些命令中来回查找。并可以通过移动光标编辑这些命令。这在修复不能通过编译的 Java程序时，可以节省时间。早于 Windows XP 的操作系统可以使用 doskey 命令支持这一功能。
```

## **模块** **5** **本章内容小结**

### **内容提要**

JDK 是 SUN 公司ᨀ供的用于创建、编译和运行 Java 程序开发包，在以命令行方式运行。本课程中我们使用 Windows 自带的记事本软件编写 Java 源程序，用 JDK 编译和运行源程序。最新版本的 JDK 可以从 SUN 公司的网站上下载（http://java.sun.com/javase/downloads/index.jsp）。下载后安装 JDK 并配置 PATH 变量和 CLASSPATH 变量。这两个变量告诉操作系统 JDK 中相关工具的位置，已经编译程序所需要的 JAVA 工具包位置。

在本主题中我们还学习了如何编写一个最简单的 JAVA 程序 EasyJava，通过这个程序我们操纵计算机在屏幕上显示“Hello World”，向世界问好。我们在记事本中输入源程序，并保存为 HelloWorld.java，注意在源程序和程序名中的大小写。我们通过键入 javac HelloWorld.java 编译程序，成功编译后会生成 HelloWorld.class 文件。键入 java HelloWorld，运行程序。会在命令行ᨀ示符后面输出“Hello World！”。这就是一个最基本的编辑编译和运行 Java程序的过程。

接下来我们分析了这个最基本的程序。EasyJava.java 是一个 Java 源文件，一个源程序内包含一个或多个类。类是 Java 中的基本单位，它是一组方法和属性的集合，Java 中所有的东西都会属于某个类，类中带有一个或多个方法。方法是一组语句的集合，是一组相关的操作计算机的指令，目的是通过系列的操作完成一项任务。EasyJava.java 中有一个类：EasyJava，该类中有一个方法 main.main 方法有三个修饰语：public 表示这个方法是公共可见的；static 表明这是一个静态方法，不需要实例化就可以执行；void 表明这个方法只执行某些指令，不向程序其它部分返回数据。在 java 程序中，语句块以“{”为开始标志，“}”为结束标志，表达了语句的作用范围，块中的内容当作一个整体来执行。main 方法中只有一句话，要求计算机向标准输出打印一串字符“Hello world！”并回车。

### **练习**

编译 Java 程序时，您实际上做了什么工作？（b） 

A．将其存盘。

b．将其转换为计算机能够理解的格式。

c．将其加入到程序集中。

答案：B

解释：java 必须先编译后执行，编译程序就是把 java 源程序转换成虚拟机能读懂的格式。



知识点：1-3-2 编译 Java 源程序

我们有一个 java 源文件 HelloWorld.java 下面哪个指令是正确的编译指令？ （d） 

A．java HelloWorld

B．java HelloWorld.java

C．javac HelloWorld

D．javac HelloWorld.java

解释：编译指令的格式为 javac 编译的源程序名，java.exe 是解释程序。

选项 AC 源文件名不完整， 选项 B 指令错误



知识点：1-3-2 编译 Java 源程序

我们有一个 java 类文件 HelloWorld.class 下面哪个指令是正确的运行指令？（c） 

A．java HelloWorld

B．java HelloWorld.class

C．javac HelloWorld

D．javac HelloWorld.class

解释：运行 Java 程序的指令格式为 java Java 类文件名，javac.exe 是编

译器程序。选项 BD，类文件错误，应该不带后缀名， 选项 A 指令错误



知识点：1-3-2 运行 Java 源程序

假设您的 JDK 安装路径是“C:\program	files\Sun\Java\JDK1.5\”；您的 path 变量应该如何配置？ (B)

A．C:\program	files\Sun\Java\JDK1.5\lib

B． C:\program	files\Sun\Java\JDK1.5\bin

C． C:\program	files\Sun\Java\JDK1.5\ 

D．C:\program	files\Sun\Java\

解释：Path 变量配置为 JDK 的 bin 目录，选项 ACD 路径错误



知识点：1-3-2 配置 PATH 变量

假设您的 JDK 安装路径是“C:\program	files\Sun\Java\JDK1.5\”	 您的 classpath 变量应该如何配置？ (A)

A．.;C:\program	files\Sun\Java\JDK1.5\lib\tools.jar

B． .;C:\program	files\Sun\Java\JDK1.5\bin

C． C:\program	files\Sun\Java\JDK1.5\ 

D．C:\program	files\Sun\Java\ JDK1.5\ lib\tools.jar

解释：CLASSPATH 变量一般配置为 JDK 的 lib 子目录下的 tools.jar 和当前目录（.），选项 BC 路径错误，选项 D 遗漏了当前目录。



知识点：1-3-3 语句块

位于左大括号和右大括号间的一组语句称为什么？（A） 

A． 语句块

B． 组件

C． 方法

D． 类

解释：语句块是用大括号括起的一组语句，选项 B 不是源代码层次上的概念，

选项 CD 都是块语句的使用实例



# **主题** **3**	 **在程序中存储信息**

## **内容提要**

在前面的主题中，我们成功的创建了第一个 Java 程序，它操纵计算机打印了一行文字“hello world！”。这个只有 5 行的程序虽然很简单，但是包含了 Java 程序的基本结构。在本主题中我们将学习如何存储信息。并且继续扩充我们的程序，使它具有这个功能。



## **学习目标**

学完本模块以后，你应该能够

· 解释常量、变量、标识符、数据类型、保留字、溢出的概念

· 列举和解释变量的不同类型、Java 的命名规则

· 在程序中使用变量和常量存储数据，给变量赋值

· 在程序中把一个变量的值赋给另一个变量

· 在程序中转换变量类型



### **重点难点**

· Java 程序语言的数据类型

· Java 程序语言中标识符的命名规则

· Java 程序语言中变量类型的转换



### **学习内容**

模块 1	 	 Java 的数据类型（建议学习时间：30 分钟）Java 程序语言中的变量和变量类型																	 				

模块 2	 	 Java 的命名规则（建议学习时间：15 分钟）Java 程序语言中的标识符是如何命名的



模块 3	 在程序中存储信息（建议学习时间：15 分钟）Java 程序语言中变量和常量的声明和赋值方式



模块 4	 	 变量类型的转换（选学：30 分钟）Java 程序语言中数据类型的转换：强制转换和自动转换，以及类型转换的风险



模块 5	 	 主题 3 内容小结（建议学习时间：10 分钟）主题 3 内容小结及习题



### **学习活动**

单元自测：《主题 3	如何在程序中存储数据 》自测



## **模块** **1 Java** **的数据类型**

### **变量和变量类型**

为了让计算机记住各种各样的信息，我们设计了一些容器来存放它们，这些容器中的信息在程序运行时是可变的，因此我们把它们称为**变量**。同时，信息的类型不同，盛放信息的容器也有好多种类型，这些类型被称为**变量类****型**。



为了方便我们区分和索引不同的变量，我们给每个变量都起了名字，这些名字（包括方法名、类名等）在计算机程序设计领域内的术语叫**标识符**，用来命名变量的标识符就是**变量名**。



要在计算机内存储信息，首先要告诉计算机我们需要什么样的容器（变量类型），然后给该容器贴个名称标签（变量名），最后再将信息放进容器（赋值），以后我们将通过这个名字找到并使用这个容器，直到程序结束或我们销毁它。因此，变量名提供了变量的标识，变量类型表明变量名所指向的容器的类型。Java 程序语言中定义了多种变量类型，如 int（整型），float（浮点型），char（字符型）等。在使用变量前，你必须明确告诉编译器你所使用变量的类型，在声明变量时要记住以下的规则：**变量必须有类型，变量必须有名称**。

下面的代码片段声明了一个整型变量 abc 和一个浮点型变量 money：

![image-20220717222154621](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717222154621.png)

有时我们会在一行语句中声明多个同类型的变量，变量和变量之间用**逗** **号**隔开，如

```
int a,b,c;
float score, totalScore;
```

**整数和浮点数**

假设我们要在程序中存放下面两个数据

· 在冰箱中放了 5 个鸡蛋

· 小明的期末平均成绩是 84.5 分

```
【动手做】
下面我们用记事本软件打开上个单元创建的 EesyJava.java。删除打印“Hello World！”的那一行，并在 main 方法中加入下列语句。保存文件，重新编译并运行该程序。
//变量存储演示
int egg = 5;
System.out.println("egg: "+egg);
float gradeAverage = 84.5f;
System.out.println("gradeAverage: "+ gradeAverage);
```

在刚才输入的程序中，第一行是一句注释。它不是程序必须的内容，这里是用来告诉读者下面的代码是用来演示变量

第二行创建一个名为 egg 的变量用来存放鸡蛋个数。语句开头的 **int** 指 定 egg 是一个用于存储整数的变量。



我们一般使用 int 类型的变量来存储计算机程序所需的大多数整数，它能够存储-2．14x109到 2．14x109 的任何整数。

语句中间的“=”是一个赋值运算符，意思是将右边的数值存放到左边的变量中。



第三行语句功能是打印 egg 变量，输出格式为“egg：”和 egg 的值。



下面我们需要一个变量来存放平均分，应该使用什么变量类型呢？由于平均分一般来说是一个小数，在 Java 中浮点类型是用来存放小数值的容器。第四行语句创建一个名为 gradeAverage 的变量来存放平均分，其中 **float** 表示变量的类型为浮点数。浮点变量用来存储可能包含小数的数值。请记住下面的

规则：**有小数点的数值必为浮点数**。在将小数 84.5 赋给变量的时候我们在数字后面加了一个“f”，表示这是一个单精度浮点数。

第五行语句和第二行语句类似，打印 gradeAverage 的值。

```
【注意】：浮点数和整数之间的差异在于浮点数可以表示小数和整数，而整数绝对不可以表示小数！即使整型变量进行数学计 算后的结果是小数，
它也会舍去小数部分变成整数。
```

### **其他的数值类型**

前面介绍了整型和浮点型变量，在编写的大多数 Java 程序也可能仅仅用到这两种数值类型。在特殊情况下，我们还可使用其他几种变量类型：第一种为 **byte** 型，取值范围为-128 到 127 的整数。第二种为 **short** 型，它的存储容量介于 byte 类型和 int 类型之间。第三种是 **long** 型，通常用于存储 int类型无法存储的整数。long 整数几乎可以任意大。浮点类型除了 float 外还有 **double** 类型（双精度类型），提供了比 float 类型更高的精度。

```
【提示】：这里每种类型的最小值和最大值不需要记忆，这里只要有各种类型占用几个字节的概念即可。
```

![image-20220717222601051](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717222601051.png)

int 和 float 是最常用的变量类型，因此除了特别需要，我们一般会将要存放整数的变量声明为 int 类型，而把要存放小数的变量声明为 float 类型。

```
【提问回答】 
问：变量名和变量是什么关系？
答：正如人有名字，我们通过名字可以区分不同的人。在程序语言中，变量名是一种标识符号，我们通过变量名区分不同的变量，并且它是我们ᨀ取变量的线索。
 
问：我们都知道 Java 中的数值类型有两种浮点类型，四种整数类型，这些类型都同样是用来存储数值，他们会有不同，为什么要定义这么多数值类型呢？ 
答：那是因为不同数值类型的容器的装载能力是不一样的，就好像是星巴克的咖啡杯，按照容量有小杯，中杯，大杯和超大杯。不同规格的杯子容量当然不一样。我们应该根据需要选择合适的杯子，250 毫升的杯子装不下 500 毫升的饮料，同样用 1000 毫升的杯子装 500 毫升的饮料也是浪费。选择合适的数据类型存储数据不仅可以避免错误，而且有时可以提高程序运行的效率。
```

![image-20220717222710433](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220717222710433.png)

### **字符和字符串**

到目前为止，大家见到的变量都是数值型的，那么我们能否用变量存储文本呢？在变量中可以存储两种类型的文本：字符和字符串。**字符**是单个字母、数字、标点符号或其他符号，大部分字符都可以在计算机键盘上找到。**字符串**是一组字符。

现在我们扩充前面的 EasyJava.java 程序，在程序中存放下面的信息：

· 你刚键入的字母是 F 

· 某个产品的名称为“爱德牌电饭锅”

```
【动手做】
在 EasyJava.java 程序，加入下面几行代码，并编译执行。
char key = ‘F’;
System.out.println("key: "+key);
String productName = "爱德牌电饭锅";
System.out.println("productName: "+ productName);
```

在上面的语句中：第一条语句是告诉计算机创建一个字符变量“key”存

放键入的字母 F，第二条语句的目的是创建一个名为 productName 的**字符串**变 量用来存放产品名称“爱德牌电饭锅”。

注意：在程序中使用字符类型的变量时，必须用**单引号**将赋给变量的字符值括起，而赋给字符串的值必须用**双引号**括起。使用这些引号将字符或字符串同变量名或其他语句部分区分开来。

```
*【注意】：除了* *String类型外，其他变量类型都是小写字母**(int**、*float* *和* *char)**，但创建字符串变量时，单词String* *的首字母必须大写。在* *Java* *程序中，字符串同在变量中存储的其他类型的信息有些不同，字符串的实质是一个对象，而非基础类型，这将在后面的章节介绍。
```

### **布尔型变量**

在编写计算机程序时，我们常常要判断一些状态，例如：用户是否按下了某个键?游戏结束了吗?这是用户首次执行某种操作吗?等等。在 Java 程序语言中为存储这些状态设计了一种特殊的变量类型叫**布尔变量**，它只能存储真 （true）或假（false）两种状态。和前面几种变量赋值的方式类似，我们可以用下面的方法定义布尔型变量并赋值。

```
boolean isOK = true;
boolean hasTag = false;
```

```
【想一想】
在 EasyJava.java 程序中再创建一个名为 gameOve 的布尔型变量用来判断游戏是否结束，设定该变量为假，并打印该值。编译并执行程序。
参考答案
class EasyJava{
public static void main(String[]arguments){
int egg = 5;
System.out.println("egg: "+egg);
float gradeAverage = 84.5f;
System.out.println("gradeAverage: "+ gradeAverage);
char key = 'F';
System.out.println("key: "+key);
String productName = "爱德牌电饭锅";
System.out.println("productName: "+ productName);
boolean gameOver = false;
System.out.println("gameOver: "+gameOver);
}
}
```

```
小常识：“布尔值”的由来
布尔值这个名词是用 George Boole 的名字命名的，George Boole 生于 1815 年，卒于 1864 年，是一名数学家，在成年前靠自学成才。他发明了布尔代数学，这是计算机编程、数字电路和逻辑学的重要组成部分。
布尔把逻辑简化成极为容易和简单的一种代数。在这种代数中，适当的材料上的“推理”，成了公式的初等运算的事情，这些公式比过去在中学代数第二年级课程中所运用的大多数公式要简单得多。这样，就使逻辑本身受数学的支配。1854 年，他发表了《思维规律》这部杰作，布尔代数问世，成为数学史上的一座新的里程碑。几乎像所有的新生一样，布尔代数发明后没有受到人们的重视。欧洲大陆著名的数学家蔑视地称它为没有数学意义的，哲学上稀奇古怪的东西，他们怀疑英伦岛国的数学家能在数学上做出独特贡献。布尔在他的杰作出版后不久就去世了。20 世纪初，罗素在《数学原理》中认为，：纯数学是布尔在一部他称之为《思维规律》的著作中发现的。”此说一出，立刻引起世人对布尔代数的注意。今天，布尔发明的逻辑代数已经发展成为纯数学的一个主要分支。
```

Java 是严格区分数据类型的语言，**在程序中使用任何变量前必须声明其类型**。前面我们提到的是 Java 的基本数据类型，除此以外还有数组、类等复合数据类型将在后面的章节中陆续向大家介绍。现在将 Java 的数据类型总结如下表：

![image-20220718215629037](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718215629037.png)

```
【提示】：在 Java 程序语言中，字符串实际上是对象，因此它应该属于符合类型中的类。
```

```
问：既然 Java 是一种具有跨平台的语言，它在各个硬件平台上的数据类型长度都
相同么？
答： Java 的基本数据类型的长度都是固定的，例如 int 在所有的计算机上都是 32 位（4 个 byte）长，char 类型使用了国际编码标准 unicode，总是 16 位（2 个 byte）长。Java的这种特性有利于 Java 的跨平台自由移植（有些高级语言，如 C++在不同的硬件平台上
字长不同）。同时由于 Java 采用 unicode，有效的解决了用 ASCII 码表示东方文字带来的不便，使得 Java 处理多语言的能力大大加强了。
```

## 模块 **2 java** 的命名规则

### 给变量命名

```
【动手做】
尝试编译下面的程序，看看编译器会反馈什么样的结果?
class VariableErr{
public static void main(String[]arguments){
int AB-C; float MyWord; char 2; String St4;
}
}
```

在命令行下编译源代码 javac VariableErr，我们会发现 JDK 向我们反馈了 4 个错误，为什么会发生这样的错误呢?因为我们对变量的命名不符合 Java 的命名原则。

我们将给变量起名字的规则称为命名规范。那么 Java 中的命名规范有哪 些?很简单，你可以根据以下的规则来命名变量(对后面讲到的类、方法同样 适用)这些规则可以保证你的命名是足够安全的，可以被编译器所接受。

· 名称必须以字母、下划线(**_**)，或美元(**$**)符号开头，不能用 数字开头，除第一个字符之外，后面可以用数字

· 在变量名中不能使用标点符号和空格 

· 在命名的时候避免使用 **java** 保留字

下表是一些命名正误的范例，通过它会对 java 的命名规则有一个具体的 了解。

| 合法命名    | 非法命名    |
| ----------- | ----------- |
| MyWord      | int         |
| S4ter       | 4erer       |
| One_hundred | One-hundred |
| GoToSee     | Go To See   |
| $           | 2           |

### 保留字

保留字是为编译器保留作为特殊用途的单词，它有专门的意义和用途， 如 class 表示类，boolean 表示布尔类型，因此不能作为标识符使用。就如你在聊天室内把自己起名为“网管”或是“聊天室管理员”，那么很快你就会被真 正的管理员勒令改名或直接被踢出聊天室。同样在 Java 中，我们不能用保留 字命名。如果你真的这么做了，编译器会拒绝编译程序，并向你报告错误。

```
 【提示】:在其他高级 程序语言中也有保留 字(有时被称为关键 字)，保留字是留给编 程语言本身使用的特 定含义的单词
```

我们在单元一中写第一个程序 HelloWorld.java 时已经接触过几个保留字: public，static，void。此外，所有的基本数据类型也是保留字:boolean，char， byte，short，int，long，float，double。

除了上面提到的部分，我们还有更多的保留字，总结如下表:

![image-20220718215801239](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718215801239.png)

```
【提示】:现在你不需 要背诵这张表格，学 到一定的程度，当你 明白这些保留字的含 义和用法，你就会自 然而然的记得这些关 键字了。
```

这当中有很多我们尚未讨论到的关键字，虽然现在你还用不到他们，但是 你必须清楚这些字在命名的时候都是应该避免使用的。

```
【动手做】 修改例程中的错误，再编译通过。
参考答案
class VariableErr{
public static void main(String[]arguments){
int ABC; float MyWord; char A2; String St4;
}
}
```

```
【想一想】 在下面一大堆的命名中，挑出其中错误的命名
MyClass，Class， anInt， int，?Hello， group， 4sat， sat5er one-hundred，tree_leaves，!，254
错误的命名有:
答案:
4sat ，one-hundred，254，int，Class，?Hello
```

除了以上的命名规则以外，在给变量取名字的时候还有两点需要注意:

· Java区分大小写，因此变量名在整个程序中大小写必须一致。例如， 如果变量 gameOver 在程序的其他地方写成 GameOver，编译程序时， 编译器会认为这是两个变量，可能导致错误。

· 给变量起一个有意义的名字，方便其他人阅读和理解程序。虽然合法但是奇怪的名字不影响程序的执行，但是在维护程序的时候将会碰 上大麻烦!

```
【􏰀问回答】
问:为什么一般我们将变量名的首字母小写?
答:这样可以将把它和 Java 程序中的其它元素区分开来，更容易识别。此外 通过采用统一的变量命名规则，在程序的不同地方使用同一变量时，不容易发 生错误。

问:两个变量可以字母相同但大小不同么? 答:Java是大小写敏感的语言，每种大小写不同的变量名都被认为是不同的变 量。我们可以故意的将大小写不同的名称作为两个变量，虽然这么做对编译器 来说是可以的，但是不建议这么做。在阅读的时候容易产生混淆。
```

## 模块 **3** 向程序中存储信息

在模块 1 的 EasyJava 程序我们已经接触了赋值运算符“=”。在本模块中我们将继续详细讨论 Java 的赋值方法。

### 变量的赋值方式

我们既可以在创建变量时就给它赋值，也可以以后在程序的任何地方给变 量赋值。赋值(指派)的意思是取得“=”运算符右边的值将该值复制到运算 符左边。右边的值可以是常量、变量，或是有能力产生数值的表达式，左边的 值必须是一个明确的变量(也就是说有盛放数据的容器)。因此我们可以将某 个常量赋值给变量(a=3)，而不能将任何值赋值给常量(3=a)。

如果要在创建变量时就给它赋初始值，可以在“**=**”后面直接打出要赋 给变量的值，表示将等号后面的值赋值给等号前面的变量，如:

![image-20220718215904232](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718215904232.png)

除此以外，我们还可以指派其他变量的值(**x=y**)来赋值或通过前面 两种方法的组合(**x=y+32**)

![image-20220718215920860](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718215920860.png)

![image-20220718215936396](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718215936396.png)

在给变量赋值的时候还有一些常见容易混淆或错误的地方:

在 Java 语言中，对字符和字符串变量赋值时，需要用引号将所要赋的值括起。字符用单引号，字符串用双引号。

```
char grade = ‘A’; 字符变量 grade 的初始值为 A 
String name =”CNN”; 字符串变量 name 的初始值为 CNN
```

布尔型变量的 true 和 false 一定不加引号。

```
boolean isCrazy=false; 变量 isCrazy 的类型为布尔型，赋为假 
String tagText=”false”; 此处是一个字符串变量，而不是布尔变量
```

而对于作为字符或字符串的数字一定要加引号，注意不要将作为字符的数 字和作为数值的数字相混淆。

```
char intial = ‘5’;      变量 intial 的类型为 char，值为’5’， 
此处的 5 是字符，而不是数字
int a = 5;              变量a的数值为5

```

还有一点需要强调的是如果没有给变量赋初值，在使用该变量前必须给它 赋值;否则，在编译程序时，编译器将给出类似下面错误消息:

![image-20220718215956879](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718215956879.png)

```
【想一想】
请根据下面的要求声明几个变量
变量名为 abc 的整型变量，并赋值 10 _______________________ 
变量名为 isClose 的布尔型变量，并赋值为 false _______________________
参考答案:
int abc = 10; 2.boolean isClose = false;
```

### 常量的声明和赋值

相对于变量来说，有些数值在程序运行的始终都不发生变化，我们将 它们称为常量。我们声明常量的目的之一就是禁止这些值被程序改变。在 Java 中用保留字 final 来实现常量的声明。常量的赋值方式和变量一样，

下面是几个例子:

```
final int NUM = 100;
final char TAG = ‘B’;
final boolean BOLD = false;
```

```
【提示】:在大部分的 编程语言中我们习惯 用完全大写的字母的 单词命名常量。
```

```
【提问回答】
问:常量的值不变，为何使用常量而不使用赋给常量的值即可? 答:使用常量的优点之一是，使程序的更容易理解。例如，Windows 系统中 Font.BOLD 和 Font.ITALIC 都是常量，它们包含表示当前字体样式的整数。优点之二是，如果需 要更改常量所代表的值，只需要给常量赋值的地方修改即可，而不用修改每一个用到常 量值的地方。
```

【补充阅读】

Java 中基本数据类型的使用方法如下:

**整数类型(字节型，短整型，整型，长整型)**

​    整型是不含小数的整数值。整型的书写可采用十进制，十六进制和八进制 形式。十进制以非 0 开头的数字，八进制以 0 开头的数字，十六进制则以 0x开头。例如:

```
int i = 15; 
int j = 017; 
int k = 0xF;
```

赋值后，这三个变量相等，其值都是十进制的 15，整型常常默认为 32 位 的 int，如果数值后面加上 L 或 l，则表示是 64 位的长整型。例如:

```
long k = 23L
```

**浮点类型(单精度，双精度)**
 Java 的浮点类型有两种表示方式
 (1) 十进制数形式，由数字和小数点组成，必须有小数点。如:123.34，0.123，123.0
 (2) 科学计数法形式，如 123e3 或 456E-3，其中 e 或 E 前必须有数字，且 e 和 E 后面的指数必须为整数
 对于一个浮点数，加上 f 或 F 后缀(f 为 float 的缩写)，表示单精度浮点数;加上 d 或 D 后缀(d 为 double 的缩写)，就是双精度浮点数。不加后缀 的浮点数默认为双精度浮点数，在计算机中占 64 位。

**字符类型**
 字符型常量由一对单引号括起来的单个字符。它可以是 unicode 字符其中的任意一个字符，如:‘a’，‘Z’，对于无法直接用键盘输入的可以用转义符号 表式。

![image-20220718220025415](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718220025415.png)

字符常量的另一种表示方法是直接写出字符编码，例如“A”的八进制表 示为“\101”，十六进制表示为“\u0041”

**布尔型**
 只有两个值 true 和 false，分别代表两种状态:真和假，直接使用这两个单词，不能加引号。例如

```
isOpen = true; 
isClose = false;
```

## **模块** **4** **类型转换（选读）**

```
【动手做】
试着编译下面的程序，看看到底会发生什么？
class convertionTest{
public static void main(String[]arguments){
int big = 12345;
byte small = big;
System.out.println(small);
}
}
```

编译上面程序的的结果是发生错误。在解读错误的提示，我们会发现编译器提示我们需要类型为 byte 的 big 变量，而目前 big 变量的类型为 int。

![image-20220718220310369](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718220310369.png)

在前面的模块中我们已经知道：不同的数据类型相当于不同的容器，那么对于同一个信息我们如何更换盛放它的容器呢？这涉及到**类型转换**的问题了。类型转换是将一个值从一种类型变为另一种类型，例如将整型更改成浮点类型，将单精度转换为整型。类型转换有可能扩大数据的存储空间，如将原来 4 个字节的内容放到能存放 8 个字节的存储空间中。相反，也有可能缩小存储空间。在 java中，扩大的空间的类型转换可以由编译器自动完成，并且总是成功的；而收缩空间的转换有可能造成数据精度丢失，或是溢出错误，因此需要程序员向编译器事先声明。

![image-20220718220355352](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718220355352.png)

那么什么是**溢出**呢？举个例子，我们不能用一个小杯装下超过其容积的液体，超过容积的部分将溢出。同样，盛放数据的容器也有一定的容量。如果你试图将一个超出类型承载能力的数值放到变量中去，为了避免发生这种错误，Java 的编译器禁止你这样操作。就算你明明知道这个数值现在是安全的，一旦 Java 编译器发现你正在将大物体装进小容器中，会有溢出的可能，它就会禁止你这么做。

当然你可以明确地声明你要这么做，其结果就是超出容器容量的部分会丢失，你会发现转换后的数值不等于原来的数值了。当然这个后果也是你自己来承担！

Java 中的类型的转换有两种方式，即自动转换和强制转换。下面我们将分别介绍这两种转换的具体内容。

**自动转换**

整型、浮点型和字符型可以进行混合运算，在运算过程中不同类型的数据先转化为同一类型后才进行运算。也就是说，在不同数据类型之间的运算过程中，系统自动对数据类型进行了转换，总是转换为最高级的那种变量类型。这种转换是安全的，因此编译器会自动进行转换。自动转换遵守的一般原则是：**从低级向高级，小容器向大容器转换，整型向浮点型转换，字符向数值转换。**

```
低ß-----------------------------------------------------------------------à高
byte  ->short  ->char	->int	->long  ->float   ->double
```

如下面的代码中，根据自动转换的原则，在进行运算时，int 的 i，将会自动转换为 float，然后和 f 相加。

```
int i = 1;

float k = 1.0f;

float sum = i+k;
```

**强制类型转换**

自动类型转换只能完成由低级向高级转换，当数据需要倒过来从高级向低级转换的时候，由于存在风险，编译器会要求我们**强制转换**。它会说：“老大，这么做是有风险的，如果您一定要我赌一把，您得给我明确的指示。”我们会说，“我知道有风险，但是我认为没问题，你就照着做吧。”这时，我们要**向编译器明确声明要进行何种转换**，声明方法有下面两种格式，这两种格式是等效的，究竟采用哪种格式依据您的编码风格决定。

**（数据类型）变量名**或**数据类型（表达式）**。

下面的例子声明将 int 类型的变量 i 强行转换成 byte 类型，并将它的值赋给 byte 型变量 b

```
int i;
byte b = (byte)i
```

下面的例子声明将 i+f 的结果转换成 int 类型并赋给变量 sum

```
int i =1;
float f=1.0f;
int sum;
sum = int(i+f);
```

```
【动手做】
在下面的程序中我们将通过强制转换来演示数据溢出的问题。将下面的代
码保存为 OverflowTest.java，编译并执行
class OverflowTest{
public static void main(String[]arguments){
    int big = 12345;
    byte small =(byte)big; 
    System.out.println(small);
    }
}
运行的结果是：我们发现 small 变量里面转载的数值仅为 57，而非原
来的 12345。多出的部分就溢出了。
```

## **模块** **5** **小结**

### **内容提要**

计算机的主要任务就是存储信息和处理信息，在程序运行过程中，存放有可能会发生变化信息的容器，这样的容器被称作**变量**。由于我们有不同类型的信息需要不同类型的容器盛放，这些类型称为**变量类型**。在程序设计语言中，**标识符**是盛放信息的容器的名字，用来ᨀ取和使用信息，**变量名**是用来命名变量的标识符。

在 Java 语言中我们对**变量声明的方式**为：变量类型+变量名。如：int	a; 和 float	m,n;

Java 中的数据类型包括**基本类型**和**复合类型**：

1. 基本类型：整型类型（byte、short、int、long）、浮点类型（float、double）、字符型（char）、布尔型（boolean）；

2. 复合类型：数组、接口、类（class）

Java 中对于标识符的命名有以下的规则：

1）名称必须以字母、下划线（_），或美元（$）符号开头，不能用数字开头，除第一个字符之外，后面可以用数字；

2）在变量名中不能使用标点符号和空格；

3）在命名的时候避免使用 java保留字。保留字是为编译器保留作为特殊用途的单词，它有专门的意义和用途，如 class，int，break 等。

将数据装入到变量中的行为叫**赋值**，Java 赋值的方式有三种：

一是直接赋给变量某个值，如 int	a	=	32;	

 二是将一个变量赋值给另一个变量，如 int	b	=	a;	 

三是将一个表达式赋值给变量 int	m	=	i+j;

**常量**是在程序运行过程中禁止发生改变的数据。Java 中用 finial 修饰符声明常量。如 int	finial	NUM=5；

Java 语言中，变量**类型转换**的规则是从低级向高级，小容器向大容器转换，整型向浮点型转换，字符向数值转换。在类型转换时有可能会溢出，即在大容器向小容器转换时的数据发生的丢失精度或错误的现象。Java 语言中的类型转换有**自动转换**和**强制转换**两种。在小容器向大容器转换时是安全的系统会自动转换，而反之则是不安全的，需要向系统声明

```
byte a = 5;	

int	b = (int)a;
```

**练习**

变量名不能用哪些字符打头？（B） 

A． 美元符号

B． 双斜线

C． 字母	 

下面的哪个赋值语句是正确的?（D） 

A、short	myshort=99s;

B、String	name=’Excellent’;

C、char	c=17c;

D、int	z=015;

下面的代码中哪两行是错误的?（B） 

![image-20220718221604185](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718221604185.png)

A、1，3 

B、2，3 

C、2，4 

D、3，4

Java 的数据类型中哪个不是基本数据类型（

c） 

A、short

B、String

C、char	

D、int	

下面哪个变量声明是正确的？（A	C	G）

​				 A.	 	 int	$x;

​				 B.	 	 int	123;	 	

​				 C.	 	 int	_123;

​				 D.	 	 int	#dim;

​				 E.	 	 int	%percent;

​				 F.	 	 int	*divide;

​				 G.	 	 int	central_sales_region_Summer_2005_gross_sales;

答案：

A,	C,	 和 G	 是合法标识符.

B	 不正确，因为不可以以数字开头

D,	E,	 和 F	 不正确，因为标识符必须以 $,	_,	 或字母开头



# **主题** **4**	 **如何修改程序中的数据**

## **内容提要**

在前面的主题中，我们学习了在程序中存储数据的容器：常量和变量。然而我们在程序中经常要对数据加工和处理，这样变量中的值就会发生变化，那么如何修改程序中的数据呢，这就涉及到本主题要向大家介绍的内容：在数学表达式中使用变量、Java 的运算符和运算符的优先级。

## **学习目标**

学完本模块以后，你应该能够

· 解释表达式的概念

· 列举和解释不同类型的运算符

· 解释和列举运算符的优先顺序

· 在程序中使用算术运算符、关系运算符、逻辑运算符

## **重点难点**

· 递增递减运算符的用法

· 多个关系运算符和逻辑运算符的组合使用

· Java 程序语言中运算符的优先顺序

## **学习内容**

模块 1	 	 算术运算符和表达式（建议学习时间：15 分钟） Java 程序语言中的算术运算符用法和递增递减运算符																				

模块 2	 	 关系运算符和逻辑运算符（建议学习时间：15 分钟）Java 程序语言中关系运算符和逻辑运算符的使用方法



模块 3	 运算符的优先级（建议学习时间：15 分钟）Java 程序语言中各种运算符的优先顺序



模块 4	 主题 4 内容小结（建议学习时间：10 分钟）主题 4 内容小结及练习题

## **学习活动**

单元自测：《主题 4	 	 如何在程序中修改数据 》自测

## **模块** **1** **算术运算**

### **表达式**

当你小时候在学校遇到的令人讨厌的数学题时，是否抱怨过,发誓今后再也不学数学了?现在，你可以让计算机帮你完成这些数学题。本单元的前面提到过，向计算机发出的涉及运算的指令被称为**表达式**。表达式告诉计算机，我们需要加工的数据（操作数）和加工的方法（运算符）。表达式会返回数据加工的结果（表达式的值）。一**个常量会一个变量名是最简单的表达式**，它返回它本身的值。我们可以像使用常量和变量一样使用表达式，甚至可以把它作为其他表达式的操作数。计算机程序中经常使用表达式完成下面这样的任务：

· 修改变量的值；

· 在程序中计数；

· 在程序中使用数学公式。

小明从工资中拿出 20000 元炒股。第一个月由于利好消息刺激，他的股票净增了 500 元，不幸的是，第二个月内又亏损了 700 元，第三个月，小明的股票比上月增长 15%，他卖掉了 1/2 的股票买基金。试问小明现在还有多少钱的股票？

```
【动手做】

我们可以编写程序是用来计算小明的股票市值，下面的程序使用了好几种算术表达式，请仔细阅读程序，并试着编译和执行它。
程序清单	 	 Stock 程序
/* 小明的股票市值
 2008/6/13 */
class Stock {
public static void main(String[] args){
float money = 20000f;
System.out.println("初始金额："+money);
//净增 500 元
money = money + 500; 
System.out.println("1 个月后："+money);
 //亏损 700 元
money = money - 700; 
System.out.println("2 个月后："+money);
//增值 15%
money = money + money * 0.15f ;
System.out.println("3 个月后："+money);
//剩余一半资金
money = money / 2;
System.out.println("期末价值："+money);
}
}
```

和我们在前面创建的其他程序一样，Stock 程序也只使用了 main()语句块。首先创建 money 变量，并将其指定为 float 类型变量，用于在程序中存放初始金额。然后在下面各个语句中分别描述股票价值的情况和变化。



### **算术运算符**

程序 Stock.java 使用了 4 种数学表达式计算股票金额。这些表达式中使用的符号(+、-、*和／)与我们数学课中的算术符号类似。它们有一个专门的术语：

**算术运算符**。在 Java 程序中用这些运算符来处理数据运算。运算符接受一个或多个操作数，并**产生新值，或改变原操作数的值**。下面的代码将变量 money 当前值加上 2 后赋给它本身。创建 money 时初始值为 150，因此 money 的值将变为 152。

![image-20220718224758899](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718224758899.png)

下面的程序片段分别对 money 变量作减法、乘法和除法运算。要注意的是，对于整型变量，除法运算的计算结果只取整数部分。要想获得小数的除法结果，必须将变量定义为浮点类型。

```
money = money – 700; -> money 的值为 19800
money = money + money * 0.15f; -> money 的值为 22770
money = money / 2; -> money 的值为 11385
```

求余数的运算在计算机专业术语中叫**求模**。要获得除法运算的余数，可使用％运算符。例如，下面的语句取 138 除以 25 的余数：

```
int weight_lost = 138 % 25;
```

![image-20220718224912467](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718224912467.png)

在同一条语句中还可以组合使用多个表达式，表达式本身可以作为另一个表达的组成部分，如下例。

```
money = money + ( money * 3 );
```

在 Java 语言中还有一种简写形式的运算符，在进行算术运算的同时进行赋值操作，由一个算术运算符和一个赋值号构成，称为算术赋值运算符。包括：+=、-=、*=、 /=、%=。

这些运算符等价于先运算后赋值的形式。例如，为了将 4 加到变量 x，并将结果赋给 x，可用 x+=4，它等价于 x=x+4。又如， x+=2-y 等价于x=x+(2-y);x*=2-y 等价于 x=x*(2-y)

### **递增和递减运算符**

除了上面ᨀ到的运算符号(+、-、*、／和％)，Java 语言中还有自增和自减两个算术运算符（++、--）分别表示将变量自增加 1，和自减少 1。假设 a是一个 int 类型变量，则表达式++a 就等价于 a = a + 1。“++”、“--”运算符的**操作数必须是整型（byte，short，int，long）或浮点型（float，double）变量**，它们对操作数执行加 1 或减 1 操作。

对“++”运算符和“--”运算符而言，都有两个版本可供选用。“前递增”表示“++”运算符位于变量的前面；“后递增”表示“++”运算符位于变量的

后面。类似地，“前递减”意味着“--”运算符位于变量的前面；“后递减”意味着“--”运算符位于变量的后面。对于前递增和前递减（如++a 或--a），会先执行运算，再生成值；而对于后递增和后递减（如 a++或 a--），则先生成值，再执行运算。

递增递减运算符在后面的 for 循环语句中大量使用，采用这类运算符会使得代码比较简练，但是如果和别的运算符放在一起，最好用括号括起，以免造成阅读的困难。例如

```
c = a -(++b);
```

下面的程序片段中分别使用了前递增和后递增,gumballs 的初始值均为28，程序运行结束后 gumballs 的值均为 29。但是，我们查看打印结果，一条语句打印 29，另一条语句打印 28，是什么原因呢？我们看看两者的差异。

```
System.out.println(++gumball);
这段代码等价于：
gumball = gumball + 1;
System.out.println(gumball); -> gumball 值为 29，打印 29
```

![image-20220718225204335](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718225204335.png)

```
System.out.println(gumball++);
这段代码等价于： System.out.println(gumball); ->gumball 值为 28，打印 28
gumball = gumball + 1;
```

![image-20220718225302497](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718225302497.png)

总结 Java 的算术运算符如下表：

| 算术运算符 | 名称                     | 实例 |
| ---------- | ------------------------ | ---- |
| +          | 加                       | a+b  |
| -          | 减                       | a-b  |
| *          | 乘                       | a*b  |
| /          | 除                       | a/b  |
| %          | 取模运算(给出运算的余数) | a%b  |
| ++         | 递增                     | a++  |
| --         | 递减                     | b--  |

```
【连连看】
下面的 Java 程序将计算并打印 x 和 y 的数值，其中有一段代码不见了。你的任务是找出下面所列出的程序段与相符的输出，将相符的两者联起来。
class Mix{
public static void main(String[] args){
int x = 0;
int y = 30;



 y -= 2;
 x = y + --x;
 //打印 x 和 y 的值
System.out.print(x + “ ”+ y); 
}
}
```

| **程序代码**   | **相应的输出** |
| -------------- | -------------- |
| x	=	x+3; | 30	28       |
| x++;           | 28	28       |
| y--;           | 26  27         |
| y=	y*5+x;   | 147	148     |

## **模块** **2** **关系运算符和逻辑运算符**

### **关系运算符**

**关系运算符**用于测试两个操作数（可能是变量，也可能是值）之间的关系。关系运算符和操作数构成的整体就是**关系表达式**。关系表达式计算的结果会**返回一个布尔值**。它们多用在控制结构的判断条件中。

Java 语言中的关系运算符和我们在数学中的习惯用法相似，如下：

| 关系运算符 | 名称     | 实例   |
| ---------- | -------- | ------ |
| ==         | 等于     | a == b |
| !=         | 不等于   | a != b |
| \>         | 大于     | a > b  |
| <          | 小于     | a < b  |
| \>=        | 大于等于 | a >= b |
| <=         | 小于等于 | a <= b |

要比较两个变量或值是否相等用“==”符号，是否不等用“!=”符号连接两个待比较的变量或值。如下例中判断变量 life 的值是否为零，再将比较结果赋给布尔型变量 isOver：

```
boolean isOver = false；
int life = 5； …
isOver = life == 0；
```

比较两个变量或值的大小用“>”、“<” “>=”和“<=”.如下例：

```
a< 10;
max > 53;
```

```
【提示】：和赋值运算符不同，逻辑运算符没有规定变量一定要放在左边，此处也可以写成 0==life，10<a不影响阅读即可。
```

要注意是，对浮点数值的比较是非常严格的。即使一个数值仅在小数部分与另一个数值存在极微小的差异，仍然认为它们是“不相等”的；即使一个数值只比零大一点点它仍然属于“非零”值。因此，**通常不比较两个浮点数值是否相等**。

对于数值，关系表达式直接比较运算符两端数值的大小或是否相等。那么字符型变量是否可以比较大小呢？**对于字符型变量我们比较它们的 ASCII码值**。根据下表，我们可以得出：‘b’>‘a’,        ‘a’>‘A’,      ‘Q’<‘f’。

![image-20220718232234033](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718232234033.png)



关系运算符一般在判断语句中使用，我们将会在下个主题中学习条件语句时大量使用关系表达式。

```
【动手做】
小明写了一个程序比较两个数值的大小，其中漏掉了一行，现在请您将这个程序补充完整，并编译执行。
class RelationalOp{
public static void main(String args[]){
float a =10.0f;
double b = 10.0;
System.out.println(result);
}
}
参考答案
boolean	result	=	a==b;
```

### **逻辑运算符**

关系运算符是获取一个条件的真假。有些情况下，需要我们将多个条件组合起来考虑，得到最终结果的真假。比如做一个人是否“年龄大于 18 岁并且身体健康的男性”的判断就需要综合考虑 3 个条件。这就需要用逻辑运算符将这些条件组合起来运算。**逻辑运算符只能用于布尔值**（也可以是结果为布尔值的关系表达式）。Java 的逻辑运算符如下：

| 逻辑运算符 | 名称 | 实例     |
| ---------- | ---- | -------- |
| &&         | 与   | a && b   |
| \|\|       | 或   | a \|\| b |
| !          | 非   | !a       |

下面列举了几个逻辑运算的例子。例如我们要判断年龄大于 4 岁并且年龄小于 8 岁

![image-20220718232730648](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718232730648.png)

如果要判断年龄小于 4 或年龄大于 8；

![image-20220718232750559](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718232750559.png)

“！”用于取布尔型变量的相反值，见下例。

![image-20220718232818630](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220718232818630.png)

在逻辑运算中，若两个操作数都是 true，则逻辑与运算符（&&）操作输出 true；否则输出 false。若两个操作数至少有一个是 true，则逻辑或运算符（||）操作输出 true，只有在两个操作数均是 false 的情况下，它才会生成一个 false。逻辑非运算符（!）属于一元运算符，它只对一个自变量进行操作，生成与操作数相反的值：若输入 true，则输出 false；若输入 false，则输出 true。对于逻辑运算运算的结果，我们可以查询下表

| A     | B     | A&&B  | A\|\|B | !A    |
| ----- | ----- | ----- | ------ | ----- |
| True  | False | False | True   | False |
| False | True  | False | True   | True  |
| False | False | False | False  | True  |
| True  | True  | True  | True   | False |

```
【动手做】 下面的程序展示了如何使用关系和逻辑运算符。在程序中计算机随机生成 两个数字，并对它们进行各种关系和逻辑运算，并打印运算结果。仔细阅读，并编译运行这个程序。
import java.util.*;
public class Bool {
public static void main(String[] args) { //生成随机数
Random rand = new Random();
int i = rand.nextInt() % 100;
int j = rand.nextInt() % 100;
System.out.println ("i = " + i);
System.out.println ("j = " + j);
System.out.println ("i > j 为 " + (i > j)); System.out.println ("i < j 为 " + (i < j)); System.out.println ("i >= j 为 " + (i >= j)); System.out.println ("i <= j 为 " + (i <= j)); System.out.println ("i == j 为 " + (i == j)); System.out.println ("i != j 为 " + (i != j)); System.out.println ("(i < 10) && (j < 10) 为 " + ((i < 10)
&& (j < 10)) );
System.out.println ("(i < 10) || (j < 10) 为 " + ((i < 10)
|| (j < 10)) ); 
}
}

注解:Random rand = new Random();创建一个随机数生成器，
int i = rand.nextInt() % 100;得到一个 0 到 100 间的随机数。
```

【补充阅读】

“短路”是Java进行逻辑运算时所独有的一个特性。在进行逻辑运算时， 只要能明确得出整个表达式为真或为假的结论，就能对整个表达式进行逻辑求 值。因此，求解一个逻辑表达式时就有可能不必要对其所有的部分进行求值。 例如，一个逻辑表达式是:

<条件1> && <条件2> && <条件3>

求解过程中，当判断出<条件 1>为假时，则整个表达式的值必定为假，不 需要再测试<条件 2> 和<条件 3>。事实上，“短路”一词的正是这么来的。

下面的例子，演示了“短路”效果，它对程序潜在性能的提升是相当可观 的。

```
public class ShortCircuit {
    static boolean test1(int val) {
        System.out.println("test1(" + val + ")");
        System.out.println("result:" + (val < 1));
        return val < 1;
    }
    static boolean test2(int val) { 
        System.out.println("test2(" + val + ")");
        System.out.println("result:" + (val < 2));       
        return val < 2;
     }
    static boolean test3(int val) {
         System.out.println("test3(" + val + ")");
         System.out.println("result:" + (val < 3));
         return val < 3;
     }
     public static void main(String[] args) {
     if(test1(0) && test2(2) && test3(2))
              System.out.println("expression is true"); 
          else
              System.out.println("expression is false");
      }

}
```

测试在下面这个表达式中进行:if(test1(0)) && test2(2) && test3(2))

按照“短路”的特性，第一个测试生成一个 true 结果，所以表达式求值 会继续下去;然而，第二个测试产生了一个 false 结果，由于这意味着整个表 达式肯定为 false，所以就没有必要再继续测试剩余的表达式。

## 模块 **3** 运算符的优先顺序

我们常常会在复杂的计算公式中使用多个算术符号，数学老师告诉我们 “先乘除，后加减;括号优先”。同样在 Java 语言中我们也可能在表达式中使 用多个运算符。那么这些运算符的先后顺序如何呢?这是最让人迷惑的。请看 下面的语句:

```
int y = 10;
x= y*3+5;
```

变量 x 的值会是多少呢?除非你知道计算机将按怎样的顺序执行该表达式中的数学运算，否则将不能确定变量 x 的值将是多少。它可能是 35 或 80， 这取决于是先计算 y*3 还是 3+5。

```
计算表达式时，按下面的顺序执行:
1.执行递增和递减运算符;
2.乘、除和求模; 
3.加和减;
4.关系运算;
5. 其他运算符号
```

根据上面的规则，由于乘法优先于加法，再看前面的例子将能够知道结果: 在最后一条语句中，先执行 y*3，结果为 30，然后再加 5，因此变量 x 的值为 35。

在写程序的时候建议使用括号来明确指定顺序。不要利用运算符的优先顺 序，那种展示技巧性的写法会降低程序的阅读性，在工程项目中是很少见到的。 如果计算式太复杂，有很多运算符嵌套在一起的话，可以引入中间变量，分成 几步写。

```
【想一想】 下列语句的运算结果是什么?
int x = 5;
int number = x++ *6+4*10/2;
答:这些语句将变量 number 的值设置为 50。 先执行++运算符，x++将变量 x 的值设置为 6。然而，注意到在该表达式中， 运算符++在 x 的后面，这意味着该表达式的值仍是变量 x 原来的值。现在 从左到右执行乘法和除法运算。首先是 5 乘 6 和 4 乘 10，然后将 4 乘 10 的结果除以 2，即(4*10/2)。表达式将变成:int number = 30 + 20。该表达 式导致变量 number 被设置为 50。
```

【补充阅读】

在一个表达式中往往存在多个运算符，此时表达式是按照各个运算符的优 先级从左到右运行的。也就是说在一个表达式中，优先级高的运算符首先执行， 然后是优先级较低的运算符，对于同优先级的运算符要按照它们的结合性来决 定。运算符的结合性决定它们是从左到右计算(左结合性)还是从右到左计算 (右结合性)。左结合性很好理解，因为大部分的运算符都是从左到右来计算 的。需要注意的是右结合性的运算符，主要有 3 类:赋值运算符(如:=、+= 等)、一元运算符(如++、!等)和三元运算符(即关系运算符)。具体的顺 序如表 2.9 所示。

| 优先级 | 运算符                                 | 名称         |
| ------ | -------------------------------------- | ------------ |
| 1      | ()                                     | 括号         |
| 2      | [],。                                  | 后缀运算符   |
| 3      | -(一元运算符，取负数),!,~,++,\--       | 一元运算符   |
| 4      | *,/,%                                  | 乘，除，取模 |
| 5      | +,-                                    | 加，减       |
| 6      | \>>,<<,>>>                             | 移位运算符   |
| 7      | \>,<,>=,<=,instanceof                  | 关系运算符   |
| 8      | ==,!=                                  | 等于，不等于 |
| 9      | &                                      | 按位与       |
| 10     | ^                                      | 按位异或     |
| 11     | \|                                     | 按位或       |
| 12     | &&                                     | 逻辑与       |
| 13     | \|\|                                   | 逻辑或       |
| 14     | ？:                                    | 关系运算符   |
| 15     | =(包括各与“=”结合的运算符,例如:+=、-=) | 赋值运算符   |

## 模块 **4** 本主题小结

### 内容提要

向计算机发出的涉及运算的指令被称为表达式。表达式告诉计算机，我们 需要加工的数据(操作数)和加工的方法(运算符)。表达式会返回数据加工 的结果(表达式的值)。一个常量会一个变量名是最简单的表达式，它返回它 本身的值。运算符接受一个或多个操作数，并产生新值，或改变原操作数的值。

程序能帮助我们完成一些重复性的任务，这些会是一些数学运算，条件判 断等等。那么就需要一些功能。编程语言中提供了各种运算符完成这些功能，

运算符的本质是一些内部函数。在进行运算的时候，它会后台调用相关的方法

函数执行相应的功能，并返回结果。

本主题中学习的 Java 的运算符如下
 1.算术运算符 (+,-,*,/,%,++,--) 

2.关系运算符 (>,<,>=,<=,==,!=) 

3.逻辑运算符 (!,&&,||)
4.赋值运算符 (=,及其扩展赋值运算符，如 +=)

在 Java 程序中用算术运算符来处理数据运算。在算术运算符中“++”、“--” 运算符的操作数必须是整型(byte，short，int，long)或浮点型(float， double)变量，它们对操作数执行加 1 或减 1 操作。

关系运算符用于测试两个操作数之间的关系。关系运算符和操作数构成的 整体就是关系表达式，计算结果会返回一个布尔值。它们多用在控制结构的判 断条件中。对浮点数值的比较是非常严格的。因此通常不比较两个浮点数值是 否相等。对于字符型变量我们比较它们的 ASCII 码值。

有些情况下，需要我们将多个条件组合起来考虑，这就需要用逻辑运算符 将这些条件组合起来运算。逻辑运算符只能用于布尔值或结果是布尔值的关系 表达式

Java 语言中我们也可能在表达式中使用多个运算符，运算符的先后顺序 比较复杂，我们只要记住“先乘除，后加减;括号优先”，其它的可以到文档 中查询。在写程序时主要用括号帮助表达运算符的优先顺序;如果计算式太复 杂，可以引入中间变量，分成几步写。



# 主题 **5** 根据某种条件执行操作

### 内容提要

在前面的主题中，我们学习了如何在程序中存储数据，以及如何在程序中 改变数据。然而我们需要让计算机更加智能化，让它能够根据判断条件做出某 种选择。例如，在编写空调器控制程序时，需要让计算机在温度超过设定温度 时开启制冷装置并显示工作状态。在本主题中我们将学习使用 if-else 和 switch-case 等条件语句完成条件判断并执行相关操作。

### 学习目标

学完本模块以后，你应该能够
· 复述if-else语句和switch-case语句的基本用法
· 在程序中使用if-else语句和switch-case语句进行条件判断 n 在程序中使用多个条件组合判断
· 在程序中嵌套使用多个条件语句

### 重点难点

· 使用与if语句对应的else语句;
· 组合多个条件测试;
· 使用switch语句进行复杂的条件测试; n 使用三元运算符创建复杂测试。

学习内容

模块 1 if 语句(建议学习时间:30 分钟) 使用 if 语句和 else 子句进行条 件判断
 模块 2 其它条件语句(建议学习时间:30 分钟)使用 switch-case 语句进行 条件筛选

模块 3 主题 5 内容小结(建议学习时间:20 分钟)主题 5 内容小结及习题

## 模块 **1** 使用 **if** 语句进行条件判断

在 Java 程序中，决策都是使用条件语句来完成的。在本单元中，我们将 在 Java 程序中使用条件语句 if、else、switch、case 来检查各种条件，还将 使用多种关系运算符，如= =、!=、 <、>和?，以及布尔型变量。

### **if**语句

在 Java 程序中要让计算机做出逻辑判断，最基本的方法是使用 if 语句。if 语句根据条件表达式的结果为真(true)还是假(false)来决定程序的执行路 径:在条件为真时执行后面的操作，条件为假的情况下直接跳转到语句结束， 不执行。使用 if 和条件来进行测试，如下面的范例所示:

![截屏2022-07-19 10.31.05](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-19 10.31.05.png)

```
【注意】:1.在 if 语句 中测试的条件要用括 号括起，如 (account<0)。 2.第一行的行尾没有 分号。所以这两行是 同一条语句。如果将 分号放在 if 部分后面， 即i(f account<0)后面， 程序将出现逻辑错 误，且很难发现。
```

上面语句的第一部分计算条件表达式的值是真还是假，第二部分显示文本 “账户中已经没有余额了!”。仅当 if 语句的第一部分为真，即变量 account 的值小于 0 时，才执行 if 语句的第二部分。

### 使用条件运算进行判断

在前面的内容中，我们已经学习了 if 语句是通过条件表达式的值来决定 是否执行随后的操作的。除了小于运算符(<)，我们在上个主题还学习了一大 堆其他关系运算符(<=,>,>=,==,!=)，下面的例子演示了如何在 if 语句中使用这些 运算符:

```
警告】:用于检测是否相等的运算符由两个等号组成，即==。
很容易将其同赋值运算符=混淆，后者用于给变量赋值。在条件语句中，总是使用两个等号。
【注意】:除字符串，可以将运算符==和!= 用于任何类型的变 量。要检测两个字符 串的值是否相等，需 要使用字符串对象的 equals()方法。
```

```
if(age>=60) 
    System.out.println(“你可以享受老年人优惠”);
if(elephantTotal<=11) 
    can_buy_another=true;
```

在程序中要检测的条件是否相等。可以使用运算符==来回答，如下面的语 句所示:

```
if(answer==rightAnswer) 
    studentGrade=studentGrade+10;
if(studentGrade==100)
    System.out.println(“棒极了!”);
```

我们也可以用条件表达式测试不相等，即一个值是否不等于另一个值，如下例所示:

```
if(answer!=rightAnswer) 
    score=score-5;
```

### 使用逻辑运算进行判断

我们常常要将多个条件放在一起判断，比如我们需要􏰁述给年龄大于五十 岁的男性。我们可以用逻辑运算符将这些条件表达式串联起来，在上个主题中 我们已经学习了逻辑运算符与、或、非。现在我们可以使用它们作为 if 语句 的条件表达式。

```
【想一想】
用 Java 语句表达下面的条件判断
1.年龄(age)大于 50 且性别(gendar)为男的职工可以参加体检 2.里程数(mileage)大于 10000 或小于 5000 的车不在此次的保修范围内
参考答案:
if( age > 50 && gendar = ‘M’) System.out.println(“您可以参加体检!”)
if( mileage < 5000 || mileage > 10000 ) System.out.println(“您的车不在此次的保修范围内!”)
```

### 使用语句块组织程序

到目前为止，所有的 if 语句后面都只跟一条指令，如 println()方法。在很 多情况下，需要根据 if 语句的条件执行多项操作，这样就需要使用多条语句。 为此需要使用成对的大括号“{”和“}”来创建语句块。

语句块是被编成组的语句。在本课程的第一单元，我们学习了如何使用 “{ ”和“}”来标识语句块的起始和结束。在程序运行时，语句块中的每条 语句都被看作为一个逻辑上的整体执行。同样当判断条件为真的情况下，if 后 面的程序块中的每个语句都会按照顺序执行。 

下面的程序片段要求计算机在公告牌上显示当前通过考试的人数，一旦有句的语句块人通过考试，就会更新屏幕内容:

```
if (score >= 60){
student_pass ++; System.out.println(“目前通过了考试的学生人数” + studnt_pass) }
```

程序的第二行将通过考试的学生人数加 1，第三行输出打印通过考试的学 生人数。如果学生的成绩大于或等于 60 分，这两条语句都执行。

### **if-else** 语句

if 语句执行的是条件为真 的操作，但是有时可能要在条 件满足时做某些事情，不满足 时做另一些事情，这时我们可 以使用 if-else 语句。

在 Java 程序中，if-else 语 句中的 if 和 else 是成对出现 的，一般 else 语句与前面离它 最近的 if 语句相匹配。

![截屏2022-07-19 11.23.48](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-19 11.23.48.png)

```
int a = 5, b = 4; if(a>b){
System.out.print("a>b"); }
else{ System.out.print("a<b");
}
```

![截屏2022-07-19 11.24.44](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-19 11.24.44.png)

可以使用 else 语句将多条 if 语句连接起来，如下例所示

```
if (grade == 'A') 
System.out.println("你的期末成绩为 A.太优秀了"); else if (grade == 'B')
System.out.println("你的期末成绩为 B.还不错"); else if (grade == 'C')
System.out.println("你的期末成绩为 C.要好好努力"); else
System.out.println("你未能通过考试，加油啊!");
```

通过这种方式将几个不同的 if 和 else 语句放在一起，可以处理很多条件。 在上面示例中，对 A 类学生、B 类学生、C 类学生和不及格的学生分别发送不 同的消息。

![截屏2022-07-19 11.26.55](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-19 11.26.55.png)

```
【提问回答】
问:关系表达式必须包含运算符么? 答:一般条件表达式包含两个操作数和一个关系运算符如 a>b，但是一个 布尔变量或布尔值 true 或者布尔变量的非运算 !isOK 也可以作为最简单的 关系表达式。
```

## 模块 **2** 其他条件语句

### **switch** 语句

if 和 else 语句非常适合于只有两种情况的情形，但有时候需要考虑两种以 上的情况。在模块 1 的最后有一个有关成绩的示例，我们结合使用 if 和 else 语句处理多种情况，但是这样做在逻辑上看起来很罗嗦，那么是否可以对它进 行简化呢?

另一种更简便的方法是使用 switch 语句，我们可以使用 switch 语句测试 多个不同的条件并做出相对的响应。这就像一排开关，switch 语句中的每一个 case 语句都是一个开关，代表一种条件。在下面我们用 switch 语句改写上面 关于成绩处理的例子。

```
switch
(grade)
{
case 'A':
//条件如果符合’A’时的入口
System.out.println("你的期末成绩为 A.真是太有才了"); 
break;

case 'B':
System.out.println("你的期末成绩为 B.还不错"); 
break;
//别忘了要中断，跳出判断，不执行后面的语句
case 'C':
System.out.println("你的期末成绩为 C.要好好努力"); 
break;
default:
//满足除上面条件外的所有条件 System.out.println("你未能通过考试，加油啊!");
}
  【注意】:每条 case 语句必须指定一个 值。如果要判断大于 或小于就不能使用 switch 语句，必须使 用一系列的 if 语句或 if-else 语句。

   
```

第 1 行的 switch 语句指定要检测的变量 grade，然后使用“{”和“}”指 定一个语句块。switch 语句中的每条 case 语句检查变量是否等于某个值，在 case 语句中使用的值必须为字符(**char** 型)或整数(**byte**，**short**，**int** 型)。 在这里，这些 case 语句中使用的 值分别是‘A’、‘B’和‘C’。每条 case 语句后跟一条或两条语句。当某条 case 语句switch 语句中变量的值匹配时，计算机将处理其后面的语句，直到遇到break 语句，使得程序的执行点跳到 switch 语句的末尾。

例如，如果变量 grade 的值为 B，将显示文本“你的期末成绩为 B.还不错”。接下来是 break 语句， 因此不会执行 switch 语句的其他 部分。Break语句告诉计算机退出 switch 语句。

default 语句是万金油，用于处理所有 case 语句都不满足的情 况，因此它总是放在最后。在这个例子中，如果变量 grade 不等于‘A’、‘B’或‘C’，将进入 default 语句。在程序中， default 语句是可选项，如果没有 default 语句，且所有 case 子语条件都不满足，将什么也不做。

在上面的例子中我们在每个 case 语句的后面都加上了 break 语句，终止 程序继续执行。如果我们不加上 break 语句会使什么样的情况呢?程序会继续 执行后面的 case 语句，直到遇上 break 或是执行完所有剩下的 case 语句到达 程序的末尾。你也许不希望这种情况发生，它很可能是一个 bug!但是有经验 的程序员有时会利用这个“副作用”达到意想不到的效果。阅读下面的程序， 仔细体会这种用法:![截屏2022-07-19 19.18.14](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-19 19.18.14.png)

```
 【注意】:如果没有 break 语句，下面的语 句仍然执行。在大多 数情况下，下面的条 件都是不成立的。因 此虽然对结果没有影 响，但是计算的效率 降低了。
```



```
//: VowelsAndConsonants.java // 判断一个字母是否是元音
public class VowelsAndConsonants {
public static void main(String[] args) {
//随机产生一个字母
char c = (char)(Math.random() * 26 + 'a'); System.out.print(c + ": "); //根据字母判断是否是元音
switch(c) {
//当字母是 a,e,i,o,u 的时候一定是元音
case 'a':
case 'e':
case 'i':
case 'o':
case 'u':
System.out.println("元音");
break;
//当字母是 y,w 时，可能是元音
     case 'y':
     case 'w':
System.out.println( "有时是元音");
break; //其它字母都是辅音
default: System.out.println("辅音");
} }
} ///:~
```

【补充阅读】

If-else 三元运算符

最复杂的条件语句是三元运算符，它有三个操作数，而且会导出一个值。 在需要根据条件测试的结果进行赋值或显示时，可以使用三元运算符。例如， 在视频游戏中，可能需要根据变量 skillLevel 是否大于 5 来设置变量

numberOfEnemies 的值。为此，我们可以使用 if-else 语句来表达:

```
if(skillLevel>5)
numberOfEnemles:10; 
else
numberOfEnemles:5;
```

另一种快捷方法是使用三元运算符，即“?”。三元运算符由 5 个部分组成，见 下图:

```
numberofEnemies=(skillLevel>5) ? 10 : 5;
// 要测试的条件，用括号括起来

//判断条件为真时的表达式 

//判断条件为假时的表达式

```

![截屏2022-07-19 19.26.14](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-19 19.26.14.png)

也可以使用三元运算符来确定要显示的信息。假如要编写这样一个程序:

根据变量 life 的值显示文本“Game is over”或“Continue”。

```

int life =5 ;
System.out.print((life == 0)? “Game is over” : “Continue”);
```

根据上面的例子可以看出，使用三元运算符可以写出很酷的代码，但它也 是 Java 中最难以掌握的关系运算符。如果觉得它难以理解，无法在程序中使 用，可以通过其他关系运算符完成同样的任务。实际上所有使用三元运算符的 场合都可以使用if和else语句来代替，三元运算符只是使得代码更简洁，执 行效率更高而已。

## 模块 **3** 本主题小结

### 内容提要

编写计算机程序时，必须将任务分成一组需要执行的步骤和需要做出的决 策。在 Java 程序中，决策都是使用条件语句来完成的。在本单元中，我们将 在 Java 程序中使用条件语句 if、else、switch、case 来检查各种条件，还将使 用多种关系运算符，如= =、!=、 <、>和?，以及布尔型变量。

if-else 语句是最常见的分支语句。if 语句根据条件表达式的结果为真还是 假来决定程序的执行路径:在条件为真时执行后面的操作。在条件为假的情况 下直接跳转到 else 子句，如果无 else 子句则直接结束。

```
 if, else 语句
 if (布尔表达式){ 语句或块;
}
if (条件为真) {
语句或块; } else {
语句或块; }
```

Switch 语句是另一种条件语句，使用该语句可以测试多个不同的条件并做 出相对的响应。这就像一排开关，switch 语句中的每一个 case 语句都是一个 开关，代表一种条件。在 switch 语句中，需要判断的表达式必须与 int 类型是 赋值兼容的;byte, short 或 char 类型可被自动转换;而其他类型表达式不可使 用。

```
switch 语句 switch (需要判断的表达式){
case 通过条件 1: //语句;
break;
case 通过条件 2: //语句;
break; default: //默认 //语句;
break;
}
 
```

除了前面讲到的两种语句，我们还可以利用三元运算符完成分支决策。三 元运算符的优点是比较精炼，缺点是可读性差。它可以被其他两种表达式代替。

```
 三元条件运算符
要测试的条件 ?条件为真时的表达式 :条件为假时的表达式
(skillLevel>5) ? 10 : 5;
```

1.在 switch 语句块中，哪条语句用于处理其他所有情况?(A) A. default
 B. otherwise
 C. elseif

D. else

2. 当条件为真和条件为假时，()控制结构可以执行不同的动作(D)

A.switch B、while C、for D、if/else

3. 下列程序片段输出的是什么?(C) int a=3;

int b=1;
 if(a=b) System.out.println(“a=”+a);

A、 a=1
 B、a=3
 C 编译错误，没有输出 D 正常运行，但没有输出

4. 下列语句执行后，x 的值为(B) int a=4,b=5,x=3;
    if(++a==b) x=x*a;
    A.3 B、12 C、15 D、20

5. 下列语句执行后，z 的值为(B) int x=3,y=4,z=0;
    switch(x%y+2)
    {

case 0:z=x*y ;break ; *

*case 6:z=x/y ;break; *

*case 12:z=x-y;break; *

*default:z=x*y-x;

}
 A、15 B、9 C、-2 D、12

# 主题 **6** 使用循环重复执行操作

## 内容提要

本主题介绍了循环的相关概念和 Java 程序设计语言中的 for 循环、while 循环等几种语句，以及复杂循环在程序中的运用。循环语句是高级程序设计的 基础知识，是构成复杂程序的基本元素。

## 学习目标

学完本模块以后，你应该能够
·使用for循环语句和while循环语句编写程序 

· 在循环中使用多个变量
 · 使用两重循环编写程序
 · 在循环中使用break和continue语句跳出循环

## 重点难点

· for循环的多种写法
· 使用多个变量作为计数器或循环条件 

· 多重循环
· break语句和continue语句



## 学习内容

模块 1 for 循环(建议学习时间:30 分钟) for 循环语句的基本用法和范例 模块 2 while 循环(建议学习时间:30 分钟) while 循环语句和 do-while 循 环语句的基本用法和范例
 模块3复杂循环(建议学习时间:30分钟) 使用多个计数器作为循环条件， 多层循环嵌套

模块 4 跳出循环(建议学习时间:30 分钟) break 语句和 continue 语句的 基本用法和范例
 模块 5 主题 6 内容小结(建议学习时间:20 分钟)主题 6 内容小结及练习题



## 模块 **1 for** 循环

### **for**循环

循环，按照日常的说法就是“转圈”，某个事物完成一圈后又返回到起点。 编写程序时，程序员经常会使用循环语句重复做某些事情，例如防病毒程序 打开每封邮件检查是否有病毒。也可以使用循环让计算机什么都不做，而只是 暂停一段时间，如动画时钟每隔一分钟显示一次时间。

for语句是一种比较复杂的循环语句，经常用于重复执行程序某部分若干 次;也可以根据特定变量值的变化情况决定循环次数。可以把这种循环看作是 要走一段路，每次前进一步，每一步都重复做某件事情。for循环的写法如下:

```
**for( int i = 0;i<100; i++) {... }**
//1设定计数器变 量和其初始值
//2使用条件表达式 判断是否继续循环
//3修改计数器变量值
//4重复执行的内容
 【提示】:此处 for 语 句中的变量 i 一般被 称为“计数器“，随 着循环的增加，计算 器的值会不断改变。


```

这行代码的意思是“重复执行...100 次”。 上面的 for 语句分成 4 个部分:

○1. 在初始化部分，设置要在 for 语句中使用 的计数器变量并赋初值。循环开始时，变量就 是赋给它的值。这部分只在进入 for 语句入口的 时候执行一次，不参与循环。

○2 条件部分包含测试，要继续循环，该测 试的结果必须为 true。一旦测试结果为 false， 循环将结束。在这个例子中，当变量 i 的值大于 或等于 100 时，循环将结束。

○3. for 语句的最后一部分包含一条以某种 方式修改计数器变量值的 Java 语句。每次循环 时这条语句都将执行。计数器变量必须以某种 方式改变其值，否则循环永远都不会结束。在 上面这个例子中，使用运算符++将变量 i 的值加 1。如果变量 i 的值不变，它将始终为初始值 0， 这样条件 i<100 将永远为 true。

○4 大括号之间的语句在每次循环时也都被 执行，这部分通常完成主要的循环任务。

![截屏2022-07-19 20.13.33](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-19 20.13.33.png)

```
【想一想】 假设你是虚拟机，你在运行该程序的时候会怎么做?
参考答案
创建变量 i，赋初始值为 0 只要 i 小于 100 就重复执行 每次执行完后将 i 的值加 1
```

下面的代码片段用于打印 1 到 20 中 3 的倍数，我们可以看到 for 语句和 if 语句的综合使用的威力。

```
for (int i=1; i<20; i++ ){ if (i%3 == 0) {
System.out.println("#: "+i) }
}
```

和 if 语句一样，如果 for 循环只包含有一条语句，可以省略大括号。设想有一个上课随便说话的小朋友，老师罚他重复抄写“我再也不上课随便讲话了”

500 遍。我们可以用下面的程序帮他完成

```
for(int p=0;p<500;p++)
System.out.println("我再也不上课随便讲话了。")
```



```
【动手做】

下面是一个程序用来计算 1 到 100 的整数与 3 的乘积，其中有两行代码缺 失了。请你补充缺失的代码，编译并运行程序。
class Triple{
public static void main(String[] args){
for(int i=1; i<=100; i++){
int result = i * 3; System.out.print(result+" ");
} }
}

```

【补充阅读】

在 for 循环语句中，计数器变量的声明和初始值也可以放在 for 语句外， 在 for 语句中留空就可以了(用来分隔语句的分号仍旧需要保留)。此外 for 语句中修改计数器变量值的语句也可以放在循环中。如果 for 语句的 3 个部分 都为空，就可以创建一个无限循环。参见下面的例子

```
nt i=4; for(;i<100;i++){ // ...
}
for(int j=20 ;j<100;){ j++;
}
for( ; ; ){ System.out.println("该循环将永远执行");
}
```

## 模块 **2 while** 循环

### **while** 循环

while循环不像for循环需要设置多个部分，在while语句中只需列出条件 表达式。下面是一个使用 while 循环语句的例子，该循环将不断重复，直到变 量 gameLives 小于或等于 0。

```
while (gameLives>0) {
//循环的内容
}
// 使用条件表达式判 断是否继续循环
//重复执行的内容

```

while语句在循环一开始，即执行循 环中的任何语句之前，就测试条件。因 此，如果程序运行到 while 语句时，测 试条件为 false，循环体中的语句将根 本不会执行。

如果 while 条件为 true，将执行循 环一次，然后再测试 while 条件。如果 在循环体内不改变测试条件，循环 将无休止的执行下去，因此要小心 无限循环。

下面的语句使用 while 循环打印一 行星号多次:

```
int limit=5;
int count=1; while(count<limit){
System.out.println(“*********”);
count++; }

【想一想】
上面的 while 循环打印四行星号，如果将变量 count 的初始值改为 4，将会打 印几行星号?如果在循环中不改变 count 的值，如何控制程序，使它还能完成 任务?
参考答案:1 行。将 count++改为 limit--
```

![截屏2022-07-19 20.19.23](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-19 20.19.23.png)





一般情况下，while 循环使用之前需要设置一个或多个变量作为循环条件。 在上例中，我们创建了两个整型变量:limit 和 count，其中 limit 的值为 5，count 的值为 1。





有时我们需要故意的将 while 语句的条件表达式设为 true，制造一个无限 循环，例如需要在服务器监听网络通讯，服务总是处于等待接受命令状态。这 时要在循环执行的语句块中设定退出循环的条件，否则循环将永远执行下去。 while(true)和我们在前面模块中学习的for( ; ; )是等效的都是制造无限循环的 方法。在下面的语句中当count的值大于100时，就执行break语句跳出循环。

```
int count = 0; while(ture){
if (count>100) break; System.out.println("*********") count++;
}
```

### **do- while** 循环

do-while 循环的功能类似于 while 循环，但条件表达式的位置不同，while 语句的判断条件放在循环语句块的前面，在每次循环开始前判断是否继续循 环，而 do-while 语句则将判断条件放在语句块后面，在每次循环结束后判断 是否要退出循环。通俗点讲，就是 for 语句和 while 语句是当什么条件满足时 就执行循环，而 do-while 语句是直到什么条件满足时才继续下一次循环。



下面是一个 do-while 循环的例子



```
do { //循环的内容 }
while (gameLives>0);

//重复执行的内容
//使用条件表达式判 断是否继续循环
//【注意】:初学者常常 会漏掉 do-while 语句 最后的“;”
```

与前面的 while 循环类似，该循环不 断执行，直到变量 gameLives 不再大于 0。 注意不管 do-while 的条成立不成立，循环 体内的语句至少会执行一次。

如果您还是不能明白 while 循环和 do-while 循环的差别，可以假想一个场景: 假设你想和老爸借车开，在一般情况下， 你可能采取两种策略:

1.先借车，用后再告诉老爸 

2.借车前就告诉老爸。
 策略 1 有一个优于策略 2 的地方，即使用条件表达式判 断是否继续循环老爸不想将车借给你用，也至少可使用一
 次。do-while 循环像策略 1，因为即使到达while 时循环条件为 false，循环也已经执行 一次。而 while 循环像策略 2，除非一开始while 条件就为 true，否则不会执行任何操作。采用哪种循环取决于程序的具 体需求。

![截屏2022-07-19 20.27.28](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-19 20.27.28.png)



```
【想一想】
在刚才学习 while 循环的时候我们使用过一个打印星号的例子。如果用 do-while 语句，我们应该如何改写这段代码才能完成同样的操作呢?
int limit=5;
int count=1; while(count<limit){
System.out.println(”*********”)
count++; }
参考答案:
int limit=5; int count=1; do{
System.out.println("*********");
count++; }while(count<limit);
注解:此处将判断条件放在末尾，由于在循环结束后才判断是否继续下次 循环，如果将 count 的初始值改为 6，虽然不符合 count<limit 的条件，还 是会有一次循环。
```

## 模块 **3** 复杂循环

### 使用多个计数器的循环

大多数 for 循环都与本章前面介绍的 for 循环差不多。如果在 for 语句中使 用多个计数器将使得循环更复杂些。我们知道在 for 循环的各个部分用分号隔 开，在 for 循环的初始化部分可以设置多个变量(但是变量的类型必须相同)， 而修改变量值的部分也可以包含多条语句，如下所示:

```
int i,j; 
for(i=0,j=0;i*j<1000;i++,j+=2){
System.out.println(i+"*"+j+" = "+i*j); 

}
```

在 for 循环的同一个部分中，语句之间用逗号隔开，如 i=0，j=0，这个循 环要显示一系列 i 乘以 j 的等式。在每次循环中，变量 i 加 1，变量 j 加 2。一 旦 i 与 j 的乘积大于等于 1000，就终止循环。

## 循环嵌套

与 Java 程序中的其他语句类似，可将一个循环放在另一个循环中，下面 的示例将一个 for 循环放在一个 while 循环中:

```
int points=0;
int target=100; 
while(target<=100){
for(int i=0;i<target;i++){ 
if(points>50)
break; 
points=points+i;
} }
```

在这个例子中，如果变量 points 大于 50，break 语句将导致退出 for 循环。 然而 while 循环永远不会结束。因为变量 target 永远不会大于 100。

在这种情况下，如果想退出两个循环，就需要给外层循环(这里是 while 循环)命名，我们将它称为标签。要给循环命名，将这个“名字”放在循环 起始位置的前一行，并在名称后加冒号**(**:**)**。标签像是一个路标，break 和 continue 语句会跳回到这里。

循环有“名字”后，就可以在 break 或 continue 语句中使用名称来指出它 们将作用于哪个循环。虽然循环的名称是在循环的开始位置且后面有冒号，但 在 break 或 continue 语句中指定循环名时不要加上冒号。

下面的例子与前面的例子相似，但有一点不同:如果变量 points 大于 50， 将结束两个循环:

```
int points=0;
int target=100; targetloop: while(target<=100){
for(int i=0;i<target;i++){ if(points>50)
break targetloop;
points=points+i;
} }
```

```
【动手做】
下面的程序是一个打印 99 乘法表的程序，其中有几行缺少了。请你将它补 充完整，并且编译执行。

参考答案
class Jiujiu{
public static void main(String[] args){
    int i,j;
    for(i=1;i<=9;i++){
       for(j=1;j<=9;j++){
         System.out.println(i+"*"+j+" = "+i*j); 
    }
} 
}
}
```

## 模块 **4** 跳出循环(选读)

### **break** 语句

正常退出循环的途径是测试条件为 false，for、while 和 do-while 三种 Java 循环都是如此。然而有时即使此时循环的测试条件为真，我们希望程序立即结 束循环，那么应该怎么办呢?为此可以使用 break 语句，break 语句告诉计算 机，“不管三七二十一，你给我跳出这个循环”。其实在前面学习 switch 语句 的时候我们已经接触了 break 语句，它使得程序跳出 switch 语句，而不是按顺 序的执行后面 case 中的程序。

在循环语句中，使用 **break** 语句忽略循环体的任何其他语句和循环条 件测试而直接跳出循环。在循环体中遇到 break 语句时，循环终止，程序从循环后面的语句继续开始执行。如下面的代码所示:

```
int index=0; while(index<=1000){
index=index+5; if(index==400)
break;
System.out.println("The index is "+index);
}
```

在该 while 循环中，测试条件是当变量 index 的值小于等于 1000 时执行循 环。而有种特殊情况导致循环􏰀前终止，这就是变量 index 为 400 时，将执行 break 语句，循环立即结束。

Java 语言中还定义了 break 语句的一种扩展形式来处理这种情况，即带标 签的 break 语句。这种形式的 break 语句，不仅具有普通 break 语句的跳转功 能，而且可以明确的将程序控制转移到标签指定的地方。带标签的 break 语句 形式为:“break 标签;”，关于带标签的 break 语句用法，请看 continue 语句 中的范例。

### **continue** 语句

可在循环中使用的另一种特殊情况语句是 continue，它导致退出本次循 环，直接进入下次循环。continue 语句只可能出现在循环语句(while、do-while 和 for 循环)的循环体中，作用是立即停止当前的循环，回到循环开始处执行 下一次循环。同 break 语句一样，continue 语句也可以跳转到一个标签处。由 于使用标签会带来阅读和逻辑上的困难，因此要避免使用这种方法，在 Java 中使用它的唯一场合是:在循环嵌套中想要跳跃一层以上的嵌套。

请看下面的例子，注意其中 continue 语句与 break 语句在循环中的区别

```
public class LabeledWhile {
    public static void main(String[] args) { 
        int i = 0;
        outer: 
        while(true) {
        System.out.println ("Outer while loop"); 
        while(true) {
            i++;
            System.out.println ("i = " + i);
            if(i == 1) {
                 System.out.println ("continue"); continue;
             }
             if(i == 3) {
                 System.out.println ("continue outer"); continue outer;
             }
             if(i == 5) {
                  System.out.println ("break");
                   break;
             }
            if(i == 7) {
                  System.out.println ("break outer"); break outer;
                }
          }
       }
      }
}
//break 语句会跳出当前循环
// 带标签的 break } 语句会跳出标签的循环
//带标签的 continue 语句会略过此次循环直接进入下一次循环
//



```



编译上面的程序并运行，结果如下:

![截屏2022-07-19 20.50.44](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-19 20.50.44.png)

通过上面的例子，我们可以比较 break 和 continue 的用法上的差异:
· continue会回到本层循环的顶端继续执行;break会跳出循环。
· 带标签的 continue 会跳跃到标签处，然后在标签后重新进入循环;

带标签的 break 会跳出标签􏰁述签的循环，不进入该循环。

## 模块 **5** 本主题小结

### 内容提要

编写程序时，程序员经常会使用循环语句重复做某些事情。Java 中的循 环语句有 for 循环和 while 循环，以及 do-while 循环 3 种，。for 和 while 循 环是在执行循环体之前测试循环条件，而 do-while 是在执行完循环体之后测 试循环条件。这就意味着 for 和 while 循环可能连一次循环体都未执行， 而 do-while将至少执行一次循环体。作为一种编程惯例，for循环一般用在那种 循环次数事先可确定的情况，而 while 和 do-while 用在循环次数事先不可确 定的情况。

for 循环写法如下

```
for 循环语句
for 语句
for (初始化计数器; 测试是否循环的布尔表达式; 改变计数器的值){
语句或语句块 }
```

```
while 循环语句
while 循环
while (测试是否循环的布尔表达式) {
语句或块 }
```

```
do-while 循环语句 
do{

语句或块
}

while (测试是否循环的布尔表达式)
```

循环是可以嵌套的，一个循环可嵌套另一个循环，也可以做为另一个循环 的一部分。

在循环语句中我们可以使用 break 或 continue 语句跳出循环



```
特殊循环流程控制

·break [标注];
· continue[标注];
· label: 语句;// where statement must be any // legal statement.
```

这两种语句的区别在于:break 语句被用来从 switch 语句、loop 语句和 预先给定了 label 的块中退出。continue 语句被用来略过并跳到循环体的结 尾。label 可标识控制需要转换到的任何有效语句，它被用来标识循环构造的 复合语句。

学完循环语句的内容后，你终于可以操作计算机，让它替你干无聊的重复 劳动了。你要做的就是写一个程序，然后泡一杯咖啡，惬意地等待程序运行结 束。啊，怎么程序运行还没结束啊?计算机好像不接受我的响应了!检查一下 你的程序代码吧，看看你是不是错误设置结束循环的条件啊。

# 主题 **7** 数组

内容提要

在计算机中存储信息的最基本的方式是将它放在变量中。数组是一组类型 相同的相关变量，可以在存储任何同类型的信息，数组的创建和使用如同变量 一样简单。本主题将向大家介绍如何创建和使用数组，以及数组在程序中的常 见用法，如排序等。

学习目标

学完本模块以后，你应该能够 n 创建和使用一维数组; n 创建和使用多维数组; n 利用数组存储信息;

· 对数组排序。 重点难点

· 数组的下标和越界检查 n 多维数组
· 利用数组进行排序

学习内容

模块 1 创建和使用数组(建议学习时间:30 分钟) 数组的概念，数组声明 和初始化，数组的赋值，使用数组的方法
 模块 2 多维数组(建议学习时间:30 分钟)多维数组的概念，二维数组用法 模块 3 数组的使用范例(建议学习时间:30 分钟) 使用数组存放数据，使 用数组排序

模块 4 主题 7 内容小结(建议学习时间:20 分钟)主题 7 内容小结及练习题 



## 模块 **1** 创建和使用数组

### 创建数组

数组是类型和标识符(名称)相同的一组变量，它能够让你根据位置来 索引，快速、随机地存取其中的内容。在前面的单元中我们用水杯来比喻变量， 而数组则可以看作是有多个水杯的杯架，杯架的每一格都按照顺序有一个数字 编号作为标签，我们要使用水杯的时候，只要根据编号就可以拿到水杯。

![截屏2022-07-19 21.05.53](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-19 21.05.53.png)

与变量一样，创建数组时也要指出存放在数组中的变量类型以及数组的 名称，不同之处在于，声明数组时我们还要多加一对方括号“[]”作为索引 的工具。数组的创建和赋值可以分为三步:1.声明数组类型;2 创建数组，指 定数组大小;3.为数组赋初始值。但是和使用变量一样，我们常常将这些步骤 合并在一起。

我们可以创建存放任何类型信息的数组。例如，下面的语句声明了一个整型数组，一个布尔型数组和一个字符串数组:

```
int[] reindeerWeights;
boolean[] hostileAirTravelNatlons; 
String[] studentNames;
```

```
【提示】创建数组时， 标识数组的方括号在位 置上是灵活的，也可以 放在变量后面，如 String names [];建议 您根据习惯选择是否采 用这种风格，并且要在 源程序中和其它数组命 名的风格一致。
```

前面的例子创建了3个数组，但此时还没有将任何数据存储到数组中。对 数组进行初始化，可以使用包含变量类型名的 new 语句，同时指明数组有多 大的存储空间，即数组最多存储多少个元素。下面的语句创建了一个名为 elfSeniority 的整型数组，该数组最多存储 250 个元素。

```
int[] elfSeniority = new int[250];
//数组类型
//数组标识

//数组名称
//数组容量

```

在使用new语句创建数组时，如果没有给数组指定初始值，编译器将自动 为数组赋初始值。初始值取决于数组的类型:对于所有数值型数组，初始值为0，字符型数组的初始值为‘\0’，布尔型数组的初始值为 false，字符串和所 有其他对象数组的初始值为 null。

对于不大的数组，可以在创建数组时直接指定初始值，这种特殊的初始化 形式是用成对的大括号括住一组值来设定的，每个值之间用逗号隔开。这种方 式下可以不用 new 语句。下面的例子创建一个字符串数组并存储了 5 个人的姓 名:

```
String[] names = {“丁一”,”王二”,”张三”,”李四”,”赵五”};
```

在上面的语句中，并没有明显的指定数组包含的元素个数，实际上该数量 就是用逗号隔开的元素个数。数组中的每个元素的类型必须相同。上面的代码 和下面的代码是等效的，通过比较你可以发现上面代码要比下面的代码简洁得 多。

```
String[] names;
names = new String[5]; names[0] = "丁一"; names[1] = "王二"; names[2] = "张三"; names[3] = "李四"; names[4] = "赵五";
```

注意:数组一旦创建，就不能增大其空间，增加其他的元素。即使又 需要添加一个名字，也不能将其作为第 6 个元素加入到数组 names 中，Java 编译器不允许我们这样做，因为有潜在的危险。

和变量一样，你也可以将一个数组指派给另一个数组。

```
int[] a = {1,2,3,4}; int[] b = a;
```

### 使用数组

在程序中使用数组和使用变量相似，只是要加上对数组中元素的索引。任 何可以使用变量的地方我们都能使用数组元素。数组名后面的方括号[]实际是 一种运算符号，表示到数组中􏰀取索引为多少的元素，因此我们甚至可以用变 量作为索引值。下面的语句是使用数组的一些范例:

```
//对数组赋值 niceChild[94] = "Max"; 
//使用算数表达式 
elfSeniority[193]+=1; 
//使用变量作为数组的索引
if(hostileAirTravelNations[currentNation] == true) sendGiftByMail();
```

需要注意的一点是，在 Java 程序语言中第 1 个元素的编号为 0，而 不是 1。这意味着最大的元素编号比数组元素的个数要小 1。请看下面的语句:

```
String[] topGifts = new String[10];
```

这条语句创建一个字符串数组，其元素的编号为 0 到 9，如果试图在程序 的某个地方使用 topGifts[10]，运行程序时就会发生错误，如下图。

![截屏2022-07-19 21.11.29](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-19 21.11.29.png)

```
 【提示】:关于什么是 异常，以及 java 的异 常处理机制请参考第 X 单元的相关内容。此 处仅需要知道数组越 界会发生异常，导致 程序不了正常执行。
```

此处的错误“ArrayIndexOutOfBoundsException”(数组越界)，也就是说 程序试图访问不在数组边界内的元素。这是相当危险的，因为你不知道那个内 存块里面存放的是什么信息。如果强制读写这个内存块就有可能发生错误。实 际上 Java 编译器在编译的时候并不能发现这个错误，但是在运行程序时会抛出异常，在发生严重错误前及时阻止你。
 为了避免越过数组边界，Java 语言规定在任何的数组中都有一个固定的成员变量 length，我们可以通过它查询数组的大小，检查数组的上界。下面 的例子创建一个数组，并打印其大小。

```
String[] weekday = { "周一","周二","周三","周四","周五","周六", "周日"}; System.out.println("数组中共有"+weekday.length+"个元素");
```

因为索引是从 0 开始的，因此我们能使用的最大索引值就是 length-1。 在这个例子中，weekday.1ength的值为7，也就是说可以指定的最大元素编号 为 6。当你试图使用 weekday[7]的时候，就会发生数组越界错误。

```
【注意】:数组的长度 是通过 String 类的 length 变量获得的， 只能用于确定数组边 界，不能通过改变 length 的值来改变数 组大小。
```

```
【动手做】 编写应用程序，声明一个整型数组{1,2,3},并对它初始化，在屏幕上输出各 元素的值和其总和。下面是程序框架，请补充完整

public class intarray{
public static void main(String args[ ]) {
int[] a={1,2,3};
int i,sum=0; for(i=0;i<a.length;i++) sum=sum+a[i]; for(i=0;i<a.length;i++)
System.out.println(" a[" +i+"]="+a[i]); System.out.println(" sum="+sum);
} }
```

【提问问答】

问:将信息存储到数组中时，必须从数组的开头开始存储吗**?** 答:可以不这样做，但这样做效率更高，因为这样数组占据的计算机内存 更少。可以从较大的索引号开始，例如，如果创建一个 for 循环，它从元 素 65 遍历到元素 90，将忽略其他元素。然而，元素 0 到元素 64 仍将占用 计算机内存，虽然没有使用它们



【补充阅读】

在 Java 中有两种处理文本的主要方式:字符串和字符数组。使用字符串 时，一种有用的技巧是将字符串中的每个字符放在字符数组的一个元素中。为 此，可使用字符串的 toCharArray()方法，它生成一个字符数组，该数组包含的元素数与字符串长度相同。

 下面的NoSpaces程序将显示一个字符串，并将其中所有的空格字符(‘’) 替换为句点(‘.’)。

```
class NoSpaces{
public static void main(String[] arguments){
String mostFamous = "Rudolph the Red-Nosed Reindeer"; char[] mfl = mostFamous.toCharArray();
for(int dex = 0; dex<mfl.length;dex++){
char current= mfl[dex];
//不是空格就打印原来的字符 if(current!=' '){
System.out.print(current); }else{
//是空格就打印圆点 System.out.print('.'); }
} }}
```

程序的第 4 行通过调用字符串 mostFamous 的 toCharArray()方法创建了 一个字符数组存放到 mfl 中。该方法将文本中的每个字符存储到数组的一个元 素中，字符R存储在元素0中，字符u在元素1中，字符d在元素2中，依此 类推，最后将字符 r 存储到元素 29 中。

在程序的第 5—12 行的 for 循环检查数组 mfl 中的每个字符，如果字符不 是空格，就直接显示它;如果是空格，就显示句点字符(.)。

## 模块 **2** 多维数组

目前为止，我们接触数组都比较简单，可以使用 0 到数组元素数个数-1 之间的数字引用数组元素，我们将它们称为一维数组。有些类型的信息超过 了一维数组的表达能力，比如在(x，y)坐标系中要存储一系列表示x和y坐标 (每对x和y坐标表示坐标系中的一个点)，这就需要使用二维数组，其中一维 用于存储 x 坐标，另一维用于存储 y 坐标。二维数组是一种特殊的一维数组， 可以这样理解:一维数组中的每个元素又是一个一维数组，两者叠加构成 二维数组。因此，二维数组是数组的数组。



![截屏2022-07-19 21.24.16](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-19 21.24.16.png)

要创建二维数组，要比创建一维数组多加一对方括号(实际上每个维度都 有一个方括号，3 维数组需要 3 对方括号)。请看下面的例子:

```
boolean[][] selectedPoint = new boolean[50][50]; 
selectedPoint[4][13]=true;
selectedPoint[7][6]=true; 
selectedPoint[11][22]=true;
```

上例创建了一个名为 selectedPoint 的布尔数组，该数组的第一维有 50 个元素，第二维也有 50 个元素，可以把它看作是一张表格，这张表格就有 50 行 50 列，总共有 2500(50x50)个格子，每个格子可以存放一个布尔变量。该 数组创建后，每个元素的默认值为 false。接下来，将其中的三个元素设置 为 true，它们在数组中的位置分别是(4，13)、(7，6)和(11，22)。

除了二维数组外，我们可以创建任意多维的数组，例如我们可以用三维数 组来􏰁述空间点。但是超过 3 维的数组就很少使用了。如果数组的维数很多， 将占用大量的内存。创建一个 50x50 的数组需要相当于创建 2500 个变量的空 间。

```
请修改上一个单元中的99乘法表程序，将运算结果填入到二维数组中，并且打印出
class Jiujiu2{
public static void main(String[] args){
int i,j;
int[][] result = new int[9][9]; for(i=1;i<=9;i++){
for(j=1;j<=9;j++){
"+i*j);
}
} 
}
}
```

```
【提问问答】
问:在多维数组中，可以使用变量 length 来确定除一维外的其他维的长度吗?
答:可以确定任何维的长度，对于第一维，可使用数组名和 length，如 x.length;对于其他维，可以使用该维的第一个元素和 length。请看下面的 数组 int[][][] data = new int [12][13][14]; 该数组第一维的长度可以使用 data.length 来确定;对于第二维，可以通过 data[0].length;对于第三维， 可以使用 data[0][0].length 来测量。
```

【补充阅读】

前面我们说过二维数组是一个特殊的一维数组，一维数组中的每个元素又是一个一维数组，则构成二维数组。所以创建二维数组另一种方式是，首先指定二维数组的行数，然后再分别为每一行指定列数。例如:

```
int[][] b=new int [2][]; 
b[0]=new int[3]; 
b[1]=new int[3];
```

这种方式可以形成不规则的数组，也就是第二维中子数组的个数是不一致 的。例如:

```
int[][] b=new int [2][]; //共 2 行 
b[0]=new int[3];//第一行有 3 个 int 元素 
b[1]=new int[10]; //第二行有 10 个 int 元素
```

二维数组也可以不用new运算符，而是通过初始化，完成定义数组变量并创建数组对象的任务。例如:

```
int[][] a ={{1,2,3},{4,5,6}};
int[][] b ={{1,2,4,5,6},{6,7,6,9}};
int[][] c ={{1,2},{6,7,6,9}};//初始化为不规则的数组
```

## 模块 **3** 数组的使用范例

### 使用数组存放数据

前面我们说过数组是一种方便快捷的存储数据的方式，利用数组我们可以 轻松存放和处理数字和字符串。假如你的英文课老师给你布置一项作业，要求 你统计一组句子中各个字母出现的频率，显然计算机是最合适的苦力，我们将 编写一个程序用来实现这个功能，下面是程序代码。

```
class LetterCount{
public static void main(String[]arguments){ 
//1 将短语存储到字符串数 组 phrase 中
    String phrase[]={
        "A STITCH IN TIME SAVES NINE",
        "DON'T EAT YELLOW SNOW",
        "JUST D0 IT",
        "EVERY GOOD BOY DOES FINE",
        "I WANT MY MTV",
        "HOW,BOUT THEM COWBOYS",
        "PLAY IT AGAIN,SAM",
        "WILL IT PLAY IN PEORIA"};
        //2 创建数组存储每个字母 的使用次数
        int[] letterCount = new int[26];
        //3遍历字符串数组，将当前 字符串转换为字符数组。
        for(int count=0; count<phrase.length;count++){ 
              String current = phrase[count];
              char[] letters = current.toCharArray();
              //4 遍历当前短语中的所有 字符，判断是字符是否是字 母，如果是就将字母相对应 的变量加一
              for(int count2=0;count2<letters.length;count2++){
                    char lett = letters[count2]; 
                    if((lett>='A')&(lett<='Z'))
                    letterCount[lett-'A']++;
 
 
   }
   //5 打印统计的结果。
   for(char count='A'; count<='Z';count++) 
   System.out.print(count+": "+letterCount[count - 'A'] +"\t"); 
   System.out.println();
} 
}
```

下面是对程序 lettercount 的详细说明:
 1 将短语存储到字符串数组phrase中，此时数组phrase的第1个元素phrase[0] 为“A STITCH IN TIME SAVES NINE”，phrase[7]的值为“WILL IT PLAY IN PEORIA”。 

2 这行代码创建整型数组 letterCount，它包含 26 个元素。用来存储每个字母 (依次为 A~Z)出现的次数。例如，letterCount[0]存储字母 A 出现的次数， letterCount[1]存储字母 B 出现的次数，依此类推，最后letterCount[25]存储 字母 Z 出现的次数。后面将会利用一个小技巧:letterCount[lett-'A']++获得某个 字母对应数组元素的位置并加 1。
 3 下面开始统计各个字母出现的频率，这部分功能通过两个相嵌套循环实现: 外层循环负责读出每个字符串，内层循环负责读出当前字符串中的每个字母， 并完成统计功能。 

外层的 for 循环遍历数组 phrase 中的所有短语。该 for 语句使用 phrase.length计算数组的长度，count 变量用来表示是字符串数组中的第几个数组，即对应 第几行字符串。下一行创建一个名为 current 的字符串变量，并将数组 phrase 中当前元素的值赋给它。外层循环的第三行创建一个字符型数组 letters，通过 字符串对象的 toCharArray 方法将字符串 current 的值赋给字符数组，存储当前 字符串中的所有字符。

```
 【提示】:字符串类型 的 toCharArray 方法可 以将本字符串变成一 个字符型数组。
```

4 内层循环也是一个 for 循环，该循环遍历当前短语中的所有字符。在内循环内创建字 符变量 lett 并将当前字符赋给它。前面我们学习过字符除文本值外，还有对应的 ASCII 码值，我们通过比较字符的 ASCII 码值比较字符的大小。因为字符在 A 到 Z 之间，我们 通过 if((lett>='A')&(lett<='Z'))语句排除了所有非字母的字符。 letterCount[lett-'A']依据当前存储在变量 lett 中的字符对应的数值，决定将数组 letterCount 中的哪个元素加 1。

```
 【提示】:这里使用了 一个小技巧。字母对 应的数值从 65(代表 ‘A’)到 90(代表‘Z’)。 由于数组 letterCount 的元素编号为 0--25， 因此为确定将哪个数 组元素加 1，将变量 lett 与‘A’相减。
```

5 这部分代码用于打印统计的结果，使用 for 循环从字母‘A’遍历到‘Z’。 System.out.print()方法用于打印字符不换行。该语句打印当前字母、冒号、该 字母出现的次数(letterCount[count - 'A'])。\t 用来插入制表符。其后的语句是 用来显示一个空行。

程序运行的结果如下图:



![截屏2022-07-21 11.19.33](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-21 11.19.33.png)

该程序演示了如何使用两个嵌套的 for 循环，以每次一个字符的方式遍历 一组短语。Java 给每个字符􏰀供了一个相关联的数值，这个值比数组中的字符 更易使用。与字符‘A’到‘Z’相关联的数值是用于 ASCII 字符集中的值。ASCII 是一种对字母、数字、标点符号和计算机能够表示的其他符号，进行排列和编 号的标准方法。通过使用 length 变量，可以在大括号间添加任意多的短语。 新增的短语中的字母也将被分析。

### 使用数组进行排序

假若你有一堆乱七八糟的名单需要将它们按照编号大小排序，那么数组的 最合适做这样的事情。排序过程中要把数组中的数值挪动位置，常见做法是 引入一个变量作为临时存放数值的容器。

请看下面的范例

```
int temp = numbers[5]; 
numbers[5] = numbers[6]; 
numbers[6] = temp;
```

在此，我们引入整型变量 temp 用作交换时的临时存储空间，先将 number[5]的值存储在 temp 中，然后将 number[6]的值赋给 number[5]，再将 temp 中 number[5]原来的值写回到 number[6]中，这样数组中的两个元素的值 就完成了交换。

移动数组元素的目标是将其按特定顺序排列。对数组排序的的方法有很多 种，下面的程序使用比较简单的冒泡法进行排序。冒泡排序的原理是将元素 N 和 N+1 相比较，并把较小的元素交换到前面，再比较 N 和 N+2，N 和 N+3，一 直到数组结束。这样元素 N 就一定比后面的元素小。然后从 N+1 开始，比较N+1 和 N+2 的大小，N+1 和 N+3，使得 N+1 比后面所有的元素小。就像冒气泡 一样，不断把最小的元素放到前面，直到所有的元素都排列到位。

```
public class BubbleSort{
public static void main(String args[ ]){
    int i,j;
    //将要排序的数字存储到数 组中
    int intArray[]={30,1,-9,70,25};
    int len=intArray.length;
    //依次读取数组中的每一个 数值
    for( i=0;i<len-1;i++){
        for( j=i+1;j<len;j++){ 
            if(intArray[i]>intArray[j]){
                int temp=intArray[i]; 
                intArray[i]=intArray[j]; 
                intArray[j]=temp;
           } 
     }
   }
for(int I=0;I<len;I++)
System.out.println(intArray[I]+ " "); 
}
}
```

【补充阅读】

在计算机中对数据排序有很多种方法，不同排序方法的名称不同，包括堆 排序、树排序和冒泡排序。Jason Harrison 提供了一个网页，它使用 Java 可视化地演示不同方法的排序速度。要查看该网页，请访问

http//www.cs.ubc.ca/spider/Harrison/Java/sortine-demo.html。

## 模块 **4** 本主题小结

内容提要

数组是类型和标识符(名称)相同的一组变量，它能够让你根据位置来索 引，快速、随机地存取其中的内容。与变量一样，创建数组时也要指出存放在 数组中的变量类型以及数组的名称，不同之处在于，声明数组时我们还要多加 一对方括号“[]”作为索引的工具。我们可以在声明数组的时候初始化，

String[] names = {“张三”,”李四”,”王二”};

也可以使用包含变量类型名的 new 语句，同时指明数组有多大的存储空 间，即数组最多存储多少个元素。

int[] elfSeniority = new int[250];

数组一旦创建，就不能增大其空间，增加其他的元素。使用数组中一个固 定的成员变量 length，查询数组的大小，检查数组的上界。在使用数组时要注 意在 Java 程序语言中第 1 个元素的编号为 0，而不是 1

二维数组可以看作是数组的数组。一维数组中的每个元素又是一个一维数 组，两者叠加构成二维数组。下面是一个二维数组的范例

int[][] twoDim = new int [4][5];

我们可以创建任意多维的数组，但是超过 3 维的数组就很少使用了。如果 数组的维数很多，将占用大量的内存。

数组适合存储列表信息，并可使用循环语句轻松地进行存取。同时，数组 具有很好的索引机制，因此我们也常用数组来排序。

### 练习

1. 数组最适合于存放什么类型的信息?(B)

 A、列表
 B、一组相关的信息
 C、 琐碎的东西

2. 什么变量用来检测数组的上界(B) 

   A、 top
    B、 length
    C、 limit

3. 下面哪个语句(初始化数组)是不正确的:(D)

    A、 int x[] = {1,2,3};
    B、 int x[3] = {1,2,3};
    C、 int[] x = {1,2,3};

   D、 intx[]=newint[]{1,2,3};

   4. 下面哪条语句正确地声明一个整型的二维数组?(C)

   A 、int a[][] = new int[][];
    B、 int a[10][10] = new int[][];

    C、 int a[][] = new int[10][10]; 

   D 、int [][]a = new int[10];

   5. 下面哪条语句定义了 5 个元素的数组( B) 

      A、int [] a={22,23,24,25,12};
       B、int a []=new int(5);
       C、int [5] array;

   ​        D、int [] arr;

# 主题 **8** 进入面向对象的世界

【导语】
 在前面我们学习了 Java 语言的基本程序语句，计算机程序是一组命令语句的 集合，计算机按照某种顺序执行这些命令。在本主题中，我们将采用面向对象 的思想设计程序。将客观世界的事务映射成为程序世界中的对象。

## 模块 **1** 用面向对象的观点看世界

### 面向对象

面向对象(Object Oriented)是一种在软件设计中分析、设计和开发的 世界观和方法论，也就是我们在软件领域内分析问题和解决问题的基本方法。 它自 20 世纪 90 年代以来一直是软件开发方法的主流。面向对象的概念和应用 已超越了程序设计和软件开发，扩展到很宽的范围。如数据库系统、交互式界 面、应用结构、应用平台、分布式系统、网络管理结构、CAD 技术、人工智能 等领域。面向对象的设计思想，使得程序更可靠，更容易理解，更容易在其他 项目中重复使用。

![截屏2022-07-21 15.49.19](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-21 15.49.19.png)

抽象是面向对象的基本概念。所谓抽象(abstraction)是强调实体的本 质、内在的属性。使用抽象可以尽可能避免过早考虑一些细节。面向对象的程 序设计中的数据抽象是把系统中需要处理的数据和施加于这些数据之上的操 作结合在一起，根据功能、性质、作用等因素抽象成不同的抽象数据类型。每 个抽象数据类型既包含了数据，也包含了针对这些数据的授权操作，并限定数 据的值只能由这些操作来观察和修改。

例如:一辆汽车可以抽象为:
· 数据:颜色、车速、名称...... 

· 操作:刹车、加速、减速......

### 对象

前面我们说过面向对象是一种看待世界方法，把客观世界的事实映射到面 向对象的程序设计中，就要相对的把需要分析的问题中的事物抽象成对象 (Object)，相对应的事物的静态特征(属性)用一组数据来􏰁述，事物的动态 特征(行为)则用一组方法来刻划。某个对象都独立于其他对象存在。对象和 对象之间通过消息通信。因此，对象包含下述内容:

1. 对象标识:即对象的名字，是用户和系统识别它的唯一标志。
2. 属性:用来描述对象的静态特征的一组数据。
3. 方法:是对象动态特征(行为)的描述。每一个方法确定对象的一种 行为或功能

例如:上图中的汽车可以看成这样一个对象:

 对象标识:Car32013 

属性:黑色、200Km/h、奥迪...... 

方法:刹车、加速、减速......

### 类

对象是对事物的抽象，而类是对同类对象的抽象和归纳。在设计类的时候 要抽象出能反映与当前目标有关的本质特征，而忽略那些与当前目标无关的非 本质特征，从而找出事物的共性，把具有共同性质的事物归结为一类。

在面向对象的编程语言中，类是一个独立的程序单位，是具有相同属性和 方法的一组对象的集合。因此类是产生对象的母版，据此决定对象应该具 有哪些属性和行为。类的概念使我们能对属于该类的全部对象进行统一的􏰁 述。因此，在定义对象之前应先定义类。􏰁述一个类需要指明下述三个方面: 

1. 类标识:类的一个有别于其它类的名字，这是必不可少的。

2. 属性:用来􏰁述相同对象的静态特征。
3. 方法:用来􏰁述相同对象的动态特征。

### 对象和类之间的关系

### ![截屏2022-07-21 16.05.22](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-21 16.05.22.png)

类给出了属于该类的全部对象的抽象定义，而对象则是符合这种定义的一 个实体。类与对象之间的关系就如同一个模具与用这个模具铸造出来的铸件之 间的关系一样。也就是说，我们可以把类与对象之间的关系看成是抽象与具体 的关系。在面向对象的程序设计中，对象被称作类的一个实例(instance)，而 类是对象的模板(template)。类是多个实例的综合抽象，而实例又是类的个 体实物。由于对象是类的实例，因此在定义对象之前应先定义类。在定义了类 之后，才可以在类的基础上创建对象。

在软件开发领域，面向对象已经逐渐成为标准方法。从某种程度上说

```
【想一想】 如果把人抽象为一个类，你能想到那些属性和方法呢?
参考答案:
属性:姓名、性别、年龄、身高、体重...... 
方法:吃饭、运动、睡觉、玩扑克、玩电脑......
```

【补充阅读】用面向对象的视角分析问题

面向对象分析的目的是对客观世界的系统进行建模。分析模型有三种用途:

 1. 用来明确问题需求;

2. 为用户和开发人员提供明确需求;
3. 为用户和开发人员提供一个协商的基础，作为后继的设计和实现的框架。

面向对象分析可以分为以下几个步骤:
 1.陈述需求 分析者必须同用户一块工作来提炼需求，因为这样才表示了用户的真实意图， 其中涉及对需求的分析及查找丢失的信息。

2、建立对象模型 首先标识和关联，因为它们影响了整体结构和解决问题的方法，其次是增加属性，进一步描述类和关联的基本网络，使用继承合并和组织类，最后操作 增加到类中去作为构造动态模型和功能模型的副产品。
 3、建立动态模型
 包括准备脚本、 确定所有外部事件、准备事件跟踪表、构造状态图等。

 4、建立功能建模

功能模型用来说明值是如何计算的，表明值之间的依赖关系及相关的功 能，数据流图有助于表示功能依赖关系，其中的处理应于状态图的活动和动作， 其中的数据流对应于对象图中的对象或属性。
 5、确定操作 

在建立对象模型时，确定了类、关联、结构和属性，还没有确定操作。只有建 立了动态模型和功能模型之后，才可能最后确定类的操作。



## 模块 **2 Java** 中的类

前面我们已经了解到类是具有相同属性和方法的一组对象的集合，接下来

我们将了解类的创建与使用。

### **Java** 语言中的类

Java语言是一种面向对象的程序设计语言，因此Java程序设计实际上就 是创建类的过程。一个 Java 源程序文件往往是由许多个类组成的。从用户的 角度看，Java 源程序中的类分为两种:

1. 系统定义的类，即 Java 类库。它是系统定义好的类。类库是 Java 语 言的重要组成部分。Java 语言由语法规则和类库两部分组成，语法规则确定 Java 程序的书写规范;类库则提供了 Java 程序与运行它的系统软件(Java 虚 拟机)之间的接口。Java类库是一组由它的发明者SUN公司以及其它软件开发 商编写好的 Java 程序模块，每个模块通常对应一种特定的基本功能和任务， 且这些模块都是经过严格测试的，因而也总是正确有效的。例如在字符界面向系统标准输出设备输出字符串时使用的方法 System.out.println()，就是系 统类 System 的静态属性 out 的方法;

2. 用户自己定义的类。系统定义的类虽然实现了许多常见的功能，但是 用户程序仍然需要针对特定问题的特定逻辑来定义自己的类。

```
【提示】:classpath 变 量的配置很重要，指明 了程序要应用的系统类 和自己定义类的路径。
```

### 类的声明

在第一单元中我们就已经学习了最基本的 Java 程序

```
/类首
public class EasyJava 
{
//类体
public static void main(String[] args){ 
      System.out.println("Hello world!");
    } 
}
```

在这个最简单的类中，我们可以看到类声明由类首与类体两部分组成，类首部 分主要是类名以及对类名的修饰符。类首部分还可以包括扩展父类和接口的相 关信息。

类体部分为一对大括号括起的语句块。在语句块中定义有类的成员变量和 成员方法。下面是一个比较完整的类声明范例:

```
public class Rectangle extends shape Implements rectangleDao

//类修饰符    //类名    //父类名                   //接口名    
 {
private float length;//长度 
private float width;//宽度
 
public float computeArea(){ 
//计算面积
}
public void printParameter(){ 
//打印参数
}
}
```

类修饰符:用来设定访问权限或及其使用方法。包括 public、abstract、final、 friendly 等。

 类名:类的标识符，区分类和别的类的依据。按照编码习惯，类名的首字母 要大写。

**extends** 父类名:表示所创建的类继承哪个类，在 Java 中只能使用单一继承， 所以只能跟一个父类名。
 **Implements** 接口名表:表明这个类实现了哪些接口，在java中可以实现多个 接口，所以可以有多个接口名。

成员变量:类的相关属性 

成员方法:类的相关方法

### 类的修饰符

有时在类名前还有一些关键字如 public，abstract 等，这些关键字被称为 修饰符，它们决定了其它类的对象是否可以使用该类，已经如何使用。常用的 类的修饰符有以下几种:

| 修饰符      | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| p u b l i c | 将一个类声名为公共类，它可以被任何对象访问                   |
| abstract    | 将一个类声名为抽象类，没有实现的方法，需要子类提供方法的实现 |
| f i n a l   | 将一个类声名为最终类及非继承类，表示它不能被其它类所继承     |

public 公共类:在默认情况下，也就是不用类修饰符的话，该类只能被同一源 程序或同一个包中的其它类使用。而加上 public 修饰符后可以被任何包中的类 使用。

```
 【注意】:在同一个源文 件中只能有一个 public 类，否则会编译出错。
```

 abstract 抽象类:这样的类是不可实例化，也就是不能直接使用，只能继承。 例如现实世界中用巧克力，饼干，面包等食品，但是并没有食品这个对象。但 是我们在分析问题的时候需要抽象出食品这个概念，它包含了所有食品的公共 特性。因此必须将食品定义成一个抽象类。

final 最终类:它不能有子类，也就是说不能被继承。final 防止别人继承你的类后修改其功能或添加新功能。在设计上用来􏰀供安全性或防止别人将你的类 改得面目全非。final 和 abstract 两个修饰符不能同时使用。

```
【想一想】 连线题:下面是关于类定义的几个关键字，请将它们连在一起
Public     
Abstract   只能被继承，不能被直接使用
Final     不能被集成 所有都类都能使用
extents      继承某个父类
implements   实现某个接口
```

## 模块 **3** 成员变量和成员方法

对象是一种组织程序的方式，对象拥有完成任务所需要的一切。为了完成工作，对象具有两部分的内容:属性和行为。属性用于存储对象中的信 息，可以是整型，字符型或布尔型变量，也可以是其他对象。行为是对象中处 理任务的一组语句，对象可以包含多个行为。行为需要的信息往往存储在本对 象的属性中或其他对象中。

映射到程序领域，类是由成员变量和成员方法组成的，接下来我们来学习 如何定义和使用成员变量以及成员方法。

### 成员变量的声明和修饰

成员变量是作为类的组成部分存在的变量，通常用来存放类的相关属性。 它描述了类的状态，有时也称之为属性、数据、域。对成员变量的操作实际上 就是改变对象的状态，使之能满足程序的需要。成员变量的声明必须放在类 体中，通常是在成员方法之前。数据成员的声明和我们前面在第二单元中 学习的变量声明方法相同。

成员变量的声明。

成员变量也有很多修饰符，用来控制对成员变量的访问。在默认情况下啊 在同一个包中的其它类可以访问此变量，而其他包中的类不能访问该变量。修 饰符是可选的主要有下面几种

```
 【注意】:其中成员变量 的访问控制符 private 与 protected 可以组合在一 起使用。其他的修饰符 都只能单独使用。
```

| 修饰符        | 定义                                                         |
| ------------- | ------------------------------------------------------------ |
| **public**    | 公共访问控制符，指定该变量为公共的，它可以被任 何对象的方法访问 |
| **private**   | 私有访问控制符。指定该变量只允许自己类的方法访 问，其他任何类(包括子类)中的方法均不能访问此 变量 |
| **protected** | 保护访问控制符。指定该变量可以被他自己的类及其 子类访问，在子类中可以覆盖此变量 |
| **friendly**  | 默认的友元访问控制符，在同一个包中的其它类可以 访问此变量，而其他包中的类不能访问该变量 |
| **final**     | 最终修饰符。指定此变量的值不能改变                           |
| **static**    | 静态修饰符。指定该变量被所有对象共享，及所有的 实例都可以使用该变量 |

2. 成员变量类型就是诸如int、float等Java允许的各种定义数据类型的关键字。 可以是基本数据类型，也可以是类。
3. 成员变量名表是指一个或多个数据成员名，即用户自定义标识符，当同时 声明多个数据成员名时，彼此间用逗号分隔。命名要符合标识符约定。

在 JAVA 中无全局变量，变量的使用范围由“{”和“}”界定。在同一使用范围 内，不允许两个变量同名。

### 成员变量的使用

类中变量使用格式是:类名.类变量名。例如:

```
public class User{
static boolean isUser;
public static void main(String[] args){
User.isUser=true; }
}
```

如果是在本类中，可以省略类名。

### 成员方法的声明与修饰

成员方法的声明。

在 Java 程序中，成员方法的声明只能在类中进行，格式如下

```
public class Square{// private float length;//边长
//修饰符      方法名
public float computeArea(float length){
//计算面积
//返回值类型 形参列表 
return length* length;
 }
 }
```

成员方法的声明包括成员方法头和方法体两部分。其中，成员方法头确定成员 方法的名字、形式参数的名字和类型、返回值的类型、访问限制和异常处理等; 方法体由包括在花括号内的说明部分和执行语句部分组成，它􏰁述该方法功能 的实现。在成员方法头中:

(1)修饰符。修饰符可以是公共访问控制符 public、私有访问控制符 private、 保护访问控制符 protected 等访问权限修饰符，也可以是静态成员方法修饰符 static、最终成员方法修饰符 final、本地成员方法修饰符 native、抽象成员方法 修饰符abstract等非访问权限修饰符。访问权限修饰符指出满足什么条件时该 成员方法可以被访问。非访问权限修饰符指明数据成员的使用方式;

| 修饰符        | 含义                                                         |
| ------------- | ------------------------------------------------------------ |
| **public**    | 公共访问控制符，指定该方法是公共的，它可以被任 何对象的方法访问 |
| **private**   | 私有访问控制符。指定该方法只允许自己类的方法访问，其他任何类(包括子类)中的方法均不能访问此方法 |
| **protected** | 保护访问控制符。指定该方法可以被他自己的类及其 子类访问      |
| **friendly**  | 默认的友元访问控制符，在同一个包中的其它类可以 访问此方法，而其他包中的类不能访问该方法 |
| **final**     | 最终修饰符。指定此方法的值不能被重载                         |
| **static**    | 静态修饰符。指定不需要实例化一个对象就可以激活 的方法        |

(2)返回值的类型。返回值的类型用 Java 允许的各种数据类型关键字(例如， int，float 等)指明成员方法完成其所定义的功能后，运算结果值的数据类型。 若成员方法没有返回值，则在返回值的类型处应写上 void 关键字，以表明该 方法无返回值;

(3)成员方法名。

 (4)形式参数表。成员方法可分为带参成员方法和无参成员方法两种。对于 无参成员方法来说则无形式参数表这一项，但成员方法名后的一对圆括号不可 省略;而对于带参成员方法来说，形式参数表指明调用该方法所需要的参数个 数、参数的名字及其参数的数据类型，其格式为:(形式参数类型 1 形式参数 名 1，形式参数类型 2 形式参数名 2，......)

```
【动手做】
我们定义一个名为 square 的公共类，它包括 1 个成员变量:边长 length, 类型为浮点型，2 个方法:计算面积 computeArea()和打印参数 printParamenter
参考答案:
public class Square{//
private float length;//边长
public float computeArea(){//计算面积
return length* length; }
public void printParameter(){//打印参数 System.out.println(“length”+ length);
} }
```

## 模块 **4** 构造函数

### 构造函数

在 Java 中，任何变量在被使用前都必须先设置初值。Java 􏰀供了为类的成员 变量赋初值的专门功能:构造函数(constructor)。构造函数是一种特殊的成 员方法，它的特殊性反映在如下几个方面:
 · 构造函数名与类名相同。

· 构造函数不返回任何值，也没有返回类型。
 · 每一个类可以有零个或多个构造函数，但是参数必须不同 l 构造函数在创建对象时自动执行，一般不能直接调用。

```
public class Box {
    double width;
    double height;
    double depth;
    // Box 的构造函数
    Box() {
    System.out.println("Constructing Box");
    width = 10;
    height = 10;
    depth = 10;
     }
     public double volume(double width,double height,double depth){
        return width* height*depth;
     }
}
class ComputeVol{
    public static void main(String args[]) {
        Box mybox1 = new Box();
        double vol;
        vol = mybox1.volume(10,10,10);
        System.out.println("Volume is " + vol); }
}
```

运行该程序，产生如下的结果:

Constructing Box Volume is 1000.0

```
【动手做】为 Shape 类写一个带有参数的构造函数。
class Shape {
private String name;//名字
public void printName(){
//打印名字 System.out.println(“name”+ name);
} }
参考答案:
Shape(String n){ n=“长方形”
}
```

### 默认构造函数

每个类至少有一个构造函数。如果不写一个构造函数，Java 编程语言将􏰀供一 个默认的构造函数。该构造函数没有参数，而且函数体为空。

```
 【注意】:如果增加一个带参数的构造函数 声明到一个类中，该类以前没有显式构造 函数，那么将失去该缺省构造函数。基于 这一点，对 new Xxx() 的调用将会引起编译 错误。认识到这一点 很重要。
```

 例如:Box() { } 如果增加一个带参数的构造函数声明，将会使缺省无效。缺省构造函数能用 new Xxx()创建对象实例，反之，你会被要求为每个类􏰀供一个构造函数。

### 构造函数的重载

一般情况下，类都有一个至多个构造函数。但由于构造函数与类同名，所以 当一个类有多个构造函数时，则这多个构造函数可以重载。只要方法与方法之 间的参数个数不同，或者是参数类型不同，便可以定义多个名称相同的方法， 这就是方法的重载。因此不难定一处构造方法的重载。构造方法的重载，可以 让用户用不同的参数来构造对象。下面举例说明。

```
public class Rectangle extends shape implements rectangleDao{
    private float length;//长度
    private int width;//宽度
    private String color;//颜色
    Rectangle () {
        length = 3.5f;
        width = 4;
        color= "红色";
    }
    Rectangle (float l, int w, String c) {
//定义有 3 个参数的构造方法
        length = l;
        width = w;
        color = c;
    }
    public float computeArea(){
//计算面积s
        return length* width;
    }
    public void showColor(){
        System.out.println("该长方形的颜色是"+color);
    }
    static class demo {
        public static void main(String[] args) {
            Rectangle rectangle1=new Rectangle ();
            System.out.println("长方形1面积是"+rectangle1.computeArea());
            rectangle1.showColor();
            Rectangle rectangle2=new Rectangle (4.5f, 6, "绿色");
            System.out.println("长方形2面积是"+rectangle2.computeArea());
            rectangle2.showColor();
        }
    }

    }
    
    程序运行结果如下: 
    长方形1面积是14 
    该长方形的颜色是红色 
    长方形2面积是27 
    该长方形的颜色是绿色

```

该程序中定义了两个构造方法 Rectangle ()，其中一个构造方法没有参数，起 作用是把私有成员变量 length 置为 3.5，width 置为 4，color 置为“红色”;第 二个构造方法 Rectangle (float l, float w)曾分别接受 float 型, int 型,和 String 型 变量，再将相应的成员变量设置为相应的值。

在主方法 main 中调用无参数的构造方法时，将成员变量 length 置为 3.5，width 置为 4，color 置为“红色”;而调用有参数的构造方法时，则 length 置为 4.5， width 置为 6，color 置为“绿色”。

## 模块 **5** 类的实例化

类是对象的产品图纸。在现实世界里，我们使用的是产品而不是产品的图纸。 同样道理，Java 运行的是用类创建的对象。一个典型的 Java 程序会创建很多 对象，它们通过消息传递进行相互交流，共同完成程序的功能。一旦任务完成， 对象就会被垃圾收集器收回，完成它从创建、使用到清除的生命三部曲。

### 创建对象

创建对象通常包括声明对象、建立对象和初始化对象三步:

1. 声明对象
    声明对象的格式如下:
    类名 对象名表; 其中:类名是指对象所属类的名字，它是在声明类时定义的;对象名表是指一 个或多个对象名，若为多个对象名时，用逗号进行分隔。例如:

class_name object_one,object_two;

2. 建立对象
    所谓建立对象，实际上就是用 Java 提供的 new 关键字为对象分配存储空间。 在声明对象时，只确定了对象的名称和它所属的类，并没有为对象分配存储空 间，此时对象还不是类的实例。建立对象的格式如下:

对象名=new 构造函数() 

例如:

object_one=new class_name(); 

object_two=new class_name();

也可以在声明对象的同时建立对象，这称为创建一个对象。创建对象的格式如下:

类名 对象名=new 构造函数()

例如:

class_name object_one=new class_name();

 class_name object_two=new class_name();

其中:new 是 Java 的关键字，也可将其称为运算符，因为 new 的作用是建立 对象、为对象分配存储空间。执行new class_name()将产生一个class_name() 类的实例(对象)。

3. 初始化对象 初始化对象是指由一个类生成一个对象时，为这个对象确定初始状态，即为它 的数据成员赋初始值。
    (1)由赋值语句赋值;
    (2)由构造函数赋值。

### 使用对象

一个对象可以有许多属性和多个方法。 当一个对象被创建后，这个对象就拥有了自己的数据成员和成员方法，我们可 以通过引用对象的成员来使用对象，对象的数据成员的引用方式如下:

对象名.数据成员名 

对象的成员方法的引用方式如下:

对象名.成员方法名(参数表)
 例如:定义一个 Rectangle 类，使其包括 length 和 width 两个数据成员和名为 computeArea、printParameter 的两个成员方法。为 Rectangle 类创建 rectangle1 和 rectangle2 两个对象。

```
public class Rectangle extends shape Implements rectangleDao{//
/**
* 以下是成员变量声明 
*/
    private float length;//长度 
    private float width;//宽度
/**
* 以下是成员方法声明 
*/
public float computeArea(){//计算面积 
    return length* width;
}
public void printParameter(){//打印参数 
    System.out.println(“length”+ length);
    System.out.println(“width”+ width); }
}
public class Example{
    public void show(){
        Rectangle rectangle1 ;
        rectangle1 =new Rectangle (); 
        Rectangle rectangle2=new Rectangle (); 
        rectangle1.length =15
        rectangle1.width =100;
        rectangle2.printParameter();
}
```

### 对象的引用

一个对象可以有 N 个引用指向它，就像可以有 N 条绳子系住一个汽球一样。 我们简单的定义一个气球的类 Balloon

```
public class Balloon { public float radial;//半径
public String color;//颜色 
public void fly(){
......
}
}
Balloon balloon1 =new Balloon (); 
Balloon balloon2 = balloon 1;
```

在系统的内存中，实际上只有一个气球，但是有两条线找到这个气球。也就是 说balloon1.fly()与balloon2 .fly()取到的是同样一个方法。

### 清除对象

很多面向对象语言要求程序员跟踪所创建的对象，当不再使用这些对象时，由 程序员负责清除他们，回收所占用的内存。这是一件很头痛经常出错的事情。 Java 引入了新的内存管理机制，由 Java 虚拟机担当垃圾收集器的工作，你可 以任意创建对象而不用担心如何清除他们，垃圾回收器会自动清除他们。 使用 new 操作符创建对象后，Java 虚拟机自动为该对象分配内存并保持跟踪。 Java 虚拟机能判断出对象是否还被引用，对不再被引用的对象释放其占用的内 存。这种定期寻找不再使用的对象并自动释放对象占用内存的过程称为垃圾收 集。Java 虚拟机实际上是利用变量生存期来管理内存的，对象的引用被保存在 变量中，当程序跳出变量所在的区域后，他就会被自动清除。

如果要明确的清楚一个对象，你可以自行清除它，只需把一个空值赋给这个对 象引用即可。如:
 Rectangle r=new Rectangle ();

...
 r=null;
 上述语句执行后，r 对象将被清除。
 Java 的垃圾收集机制大大减轻了程序员的负担，你不用再编写专门的内存回收 程序解决内存分配问题。不仅􏰀高了编程效率，而且进一步增强了 Java 程序 的稳固性。

# 主题 **9** 深入面向对象

【导语】 在面向对象的世界中也存在自然界中的一些概念，比如继承，多态等。继

承简化了人们对事物的认识和􏰁述，能清晰体现相关类间的层次结构关系。􏰀 供软件复用功能，大大增加程序的重用性和易维护性。多态是指一个同名的方 法可以有不同的版本，调用这个方法时只是调用了该方法不同版本中的一个。 多态性事项系统添加新的功能变得容易，使得调用者的调用格式趋于一致，是 降低软件复杂性、􏰀高软件易用性的有效技术。

## 模块 **1** 继承(**1**)

继承是面向对象程序设计的重要特性。类继承也称为类派生，是指一个 类可以继承其他类的非私有成员，实现代码复用。新类从现有的类中产生，保 留了现有类的属性和方法并根据需要加以修改。新类还可添加新的属性和方 法，这些新增功能允许以统一的风格处理不同类型的数据，这种现象就称为类 的继承。继承简化了人们对事物的认识和􏰁述，能清晰体现相关类间的层次结 构关系。􏰀供软件复用功能，大大增加程序的重用性和易维护性。

### 父类和子类

类的继承性使得你在建立一个新类时，不必写出全部成员变量和成员方 法。只要简单地声明这个类是从另一个已定义的类继承下来的，就可以使用被 继承类的全部成员。这样的设计减少了代码的重复，􏰀高了代码的质量和可靠 性。被继承的类称为父类或超类，父类包括所有直接或间接被继承的类;继承 父类或超类后产生的类称为派生类或子类，如果客轮类继承轮船类，那么轮船 是客轮的父类，客轮是轮船的子类。创建子类的方法与创建类的方法相同，只 是通过关键字 extends 添加相应的父类名称。

```
【说明】:如果省略 了 extends，子类默认 继承 java.lang 包中 的 Object 类，它是所 有类的始祖。
```

```
public class Account{};//帐户类
public class User extends Account {};//普通用户类 //Account是父类名
public class Manager extends Account {};//管理者类
public class HRManager extends Manager {};//人力资源管理者类
```

第一条语句定义类 Account，在字面上没有 extends，但实际上等价于 public class Account extends Object{};第二条语句声明 User 的父类是 Account;第三 条语句声明 Manager 的父类也是 Account;第四条语句声明 HRManager 的父 类是 Manager。

他们的关系如下图(下面的图片中用老爷爷，中年人和小孩代表继承关系)

![截屏2022-07-21 19.12.07](/Users/wangzhennan/Library/Application Support/typora-user-images/截屏2022-07-21 19.12.07.png)

子类继承父类的所有非私有成员，也继承父类的父类直至祖先所有的所有 非私有成员。上例中的类 HRManager 继承类 Manager 和 Account，以及类 Object 的非私有成员(如果没有被覆盖的话)。继承是在一些比较一般的类的基础上 构造、建立和扩充新类的最有效的手段。子类继承了父类和祖先的成员，可以 使用这些成员。在需要的时候，子类可以添加新的成员变量和方法，也可以隐 藏父类的成员变量或覆盖父类的成员方法。

综上所述，我们得到如下结论:

· Java语言以Object类作为所有类的父类。
 · Java中的继承是通过extends关键字来实现的。
· 一个类可以有多个子类，也可以没有子类，但它必定有一个父类

(Object 类除外)。 

· 类继承具有传递性。

### 成员变量的继承和隐藏

数据成员的隐藏是指在子类中重新定义一个与父类中已定义的数据成员 名完全相同的数据成员，即子类拥有了两个相同名字的数据成员，一个是继承 父类的，另一个是自己定义的。当子类引用这个同名的数据成员时，默认操作 是它自己定义的数据成员，而把从父类那里继承来的数据成员“隐藏”起来。 当子类要操作继承自父类的同名数据成员时，可使用关键字 super 引导。

我们对 2.1 中的例子进行扩展，根据实例看一看成员变量的继承与隐藏。

```
public class Account{//帐户类 
    private int year;//年龄
    protected String name;//姓名 
    protected String roleCode;//角色代码 
};
public class Manager extends Account {//管理者类 
    protected String roleCode;// 管理者角色代码 
    protected String level;// 管理者级别
};
public class HRManager extends Manager {//人力资源管理者类 
    protected String level;// 人力资源管理者级别
    protected String workSpace;//工作地点
};

```

上例中，Account 是父类，Manager 继承 Account，HRManager 继承 Manager。 我们分析一下这三个类各自都有哪些成员变量。

|  Account | Manager           | HRManager    |
| -------: | ----------------- | ------------ |
|     year |                   |              |
|     Name | Name              | Name         |
| roleCode | roleCode/roleCode | roleCode     |
|          | Level             | level /level |
|          |                   | workSpace    |

从上面的图表可以看出:
 父类 Account 中有三个变量:year、 name 和 roleCode。 子类Manager继承了Account中的name，隐藏了Account中的roleCode，

添加了自己的成员变量 level。由于 Account 中 year 变量是私有的，因此子类 Manager 并没有继承。

子类 HRManager 继承了 Account 中的 name 和 Manager 中的 roleCode， 隐藏了 Manager 中的 level，添加了自己的成员变量 level。

由于有了继承和隐藏，在子类中要特别注意成员变量的命名，防止无意中 隐藏了父类的关键成员变量，这有可能给你的程序带来麻烦。

```
【动手做】如果 Account、Manager 和 HRManager 的定义不变，定义类 A 继承 HRManager ，那么 A 继承的成员变量、隐藏的成员变量和添加的成员 变量各是什么?
public A extends HRManager{ 
protected String workSpace;
protected Date startTime; 
}
参考答案:继承的成员变量是 name、 roleCode 和 level，隐藏的成员变量 是 workSpace ，添加的成员变量是 startTime。
```

### 成员方法的覆盖

与成员方法的隐藏类似，子类可以重新定义与父类同名的成员方法，实现 对父类方法的覆盖。方法的覆盖与数据成员的隐藏的不同之处在于:子类隐藏 父类的数据成员只是使之不可见，父类同名的数据成员在子类对象中仍然占有 自己的独立的内存空间;而子类方法对父类同名方法的覆盖将清除父类方法占 用的内存，从而使父类方法在子类对象中不复存在。

· 覆盖方法的返回类型必须与它所覆盖的方法相同
 · 覆盖方法应与父类有完全相同的方法名、返回值类型和参数列表 l 覆盖方法不能比它所覆盖的方法访问性高
 · 覆盖方法不能比它所覆盖的方法抛出更多的异常

尽管一个子类从父类继承所有的方法和变量，但它不继承构造函数，掌握 这一点很重要。一个类能得到构造函数，只有两个办法。或者写构造函数，或 者根本没有写构造函数，类有一个缺省构造函数。

仍然是 Account、Manager 和 HRManager 的例子，我们加入相应的成员 方法认识成员方法的覆盖。



```
 【注意】:不能覆盖 父类中的 final 方法， 因为设计这类方法的 目的就是为了防止覆 盖。
```

```
public class Account{
//帐户类 
public void final end (){
System.out.println(“Account 中的 end 方法是 final 的方法，不能继 承”);
}
public boolean println (){ 
System.out.println(“Account 中的 println 方法”);
   return true;
  
  }
public String toString (){
return “Account 中的 toString 方法”; 
}
}
public class Manager extends Account {//管理者类 
public boolean println (String s){
System.out.println(“Manager 中的 println 方法”+s); 
return true;
}
public String toString (){
return “Manager 中的 toString 方法”; 
}
public String show (){ 
System.out.println(“Manager 中的 show 方法”);
return “success”;
}
}
public class HRManager extends Manager {//人力资源管理者类 public boolean println (){
System.out.println(“HRManager 中的 println 方法”); 
return true;
}
public boolean show (){
System.out.println(“HRManager 中的 show 方法”); 
return false;
}
}
```

上例中，Account是父类，Manager继承Account，HRManager继承Manager。

我们分析一下这三个类各自都有哪些成员方法。

| Account              | Manager                                   | HRManager                        |
| -------------------- | ----------------------------------------- | -------------------------------- |
| void final end()     |                                           |                                  |
| boolean println()    | boolean println	()                     | boolean	 	 println	()   |
| String	toString() | String	toString	()                  | String	toString	()         |
|                      | boolean	 	 println	(String	s) | boolean println	(String	s) |
|                      | String show	()                         | String	show	()             |
|                      |                                           | boolean	show	()            |

从上面的图表可以看出：父类 Account 中有三个方法：end	 ()、 println	 ()和 toString	 ()。子类 Manager 中也有 toString	 方法。由于 toString 和继承下来的方法同名（都是 toString）、同参数（都没有参数）、同返回值类型（都是 String），因此就覆盖了父类中的 toString 方法。与此不同的是子类 Manager 中的 println	(String	s)方法，虽然和继承下来的方法 println	()相比，方法名和返回值类型都相同，但是由于参数不同，因此它就不是方法的覆盖，而是子类定义自己特有的方法，与父类的方法无关。此外，Manager 继承了 println	()方法，添加了 show	()方法。子类 HRManager 中继承了 toString	()、println	(String	s)和 show	()方法，覆盖了父类中的 println	 ()方法。虽然 show	 ()和继承下来的方法 show	 ()相比，方法名和参数都相同，但是由于返回值类型不同，因此它就不是方法的覆盖，而是子类定义自己特有的方法，与父类的方法无关。子类也不能覆盖父类中的static 方法，但可以隐藏这类方法。也就是说在子类中生命的同名静态方法实际上隐藏了父类中的静态方法。

```
【动手做】如果 Account、Manager 和 HRManager 的定义不变，
定义类 B 继承 HRManager。
那么，B 继承的成员方法、覆盖的的成员方法和添加的成员方法各是什么？
public B extends HRManager{
public boolean println (boolean s){
System.out.println(“B 中的 println 方法”+s);
return true;
}
}
参考答案：继承的成员变量是 println()、toString()、println(String s)、
String	show()和 boolean	show()，没有隐藏的成员方法，添加的成员方法是
println	(boolean s)。
虽然 println	(boolean s)	 和继承下来的方法 println()和 println(String	s)
相比，方法名和返回值类型相同，但是由于参数不同，因此它就不是方法的覆盖，而是子类定义自己特有的方法。
```

## **模块** **2** **继承（****2****）**

**this** **的用法**

在一些容易混淆的场合，例如，成员方法的形参名与数据成员名相同，或者成员方法的局部变量名与数据成员名相同时，在方法内借助 this 来明确表示引用的是类的数据成员，而不是形参或局部变量，从而提高程序的可读性。简单地说，this 代表了当前对象的一个引用，可将其理解为对象的另一个名字，通过这个名字可以顺利地访问对象、修改对象的数据成员、调用对象的方法。归纳起来，this 的使用场合包括：

（1）用来访问当前对象的数据成员，其使用形式如下：

​		 this.数据成员

（2）用来访问当前对象的成员方法，其使用形式如下：

​			 this.成员方法（参数）

见下例

```
class A {
int x=10;
int	 y=20;
int area(int x,int	 y)
{
System.out.println(“x=”+x+” y=”+y);
System.out.println(“this.x=”+this.x+” this.y=”+this.y);
this.x=x;
this.y=y;
int s=this.x*this.y;
return	s;
}
int	 countArea(){
return	this.x*this.y;
}
```

运行结果是：

Z1=200

x=6	y=8

this.x=10	this,y=20

z2=48

### **super** **的用法**

super 表示的是当前对象的直接父类对象，是当前对象的直接父类对象的引用。所谓直接父类是相对于当前对象的其它“祖先”类而言。例如，假设类 A派生出子类 B，B 类又派生出自己的子类 C，则 B 是 C 的直接父类，而 A 是 C的祖先类。super 代表的就是直接父类。若子类的数据成员或成员方法名与父类的数据成员或成员方法名相同时，当要调用父类的同名方法或使用父类的同名数据成员，则可用关键字 super 来指明父类的数据成员和方法。super 的使用方法包括：

（1）用来访问直接父类隐藏的数据成员，其使用形式如下：

super.数据成员

（2）用来调用直接父类中被覆盖的成员方法，其使用形式如下：

super.成员方法（参数）

```
/**
 * @author shkstart
 * @create 2022-07-21 22:20
 */

class	A1 {
    int	x=4;
    int	y=1;
    public	void printme()
    {
        System.out.println("x="+x+"	y="+y);
    }
}
class B1 extends A1{
    int	x;
    public	void	printme()
    {
        int	z=super.x+6;
        super.printme();
        x=5;
        System.out.println("z="+z+"x="+x);
    }
    public	static	void main(String arg[])
    {
        A1 a = new A1();
        B1 b = new	B1();
        a.printme();
        b.printme();
    }
}

```

运行结果如下：

x=4	y=1

x=4	y=1

z=10	x=5

### **调用父类的构造函数**

通常要定义一个带参数的构造函数，并要使用这些参数来控制一个对象的父类部分的构造。可能通过从子类构造函数的第一行调用关键字 super 的手段调用一个特殊的父类构造函数作为子类初始化的一部分。要控制具体的构造函数的调用，必须给 super()提供合适的参数。当不调用带参数的 super 时，缺省的父类构造函数（即，带 0 个参数的构造函数）被隐含地调用。在这种情况下，

如果没有缺省的父类构造函数，将导致编译错误。

```
public class Employee {
    String name;
    public Employee(String n) {
        name = n;
    }
}
class Manager extends Employee {
    String department;
    public Manager(String s, String d) {
        super(s);
        department = d;
    }
}
```

## **模块** **3** **多态和抽象类**

### **为什么要使用多态**

简单地说，多态是指一个同名的方法可以有不同的版本，调用这个方法时只是调用了该方法不同版本中的一个。多态性事项系统添加新的功能变得容易，使得调用者的调用格式趋于一致，是降低软件复杂性、提高软件易用性的有效技术。

这些方法同名的原因，是它们的最终功能和目的都相同，但是由于在完成同一功能时，可能遇到不同的具体情况，所以需要定义含不同的具体内容的方法，来代表多种具体实现形式。它是面向对象程序设计中的一个特性。其目的是为了提高程序的抽象度、封闭性和简洁性，统一一个或多个相关类对外的接口。

就像我们平时用的插头一样，虽然都叫做插头，但是有的是两插头的、有的是三插头的，有的是圆的，有的是扁的。这就要求我们设计不同的插板。

### **成员方法的重载**

在某些情况下，可能要在同一个类中写几种做同样工作但带有不同参数的方法。考虑一个简单方法，它试图输出参数的文本表示法。这种方法被称做println()。

现在假设打印每个 int，float，String 类型需要不同的打印方法。这是合情合理的，因为各种数据类型要求不同的格式，而且可能要求不同的处理。可以分别创建三种方法，即：printInt(),printfloat()和 printString()。但这是很乏味的。Java 与其它几种编程语言一样，允许对不止一种方法重用方法名称。清楚地说，只有当某种东西能区分实际上需要哪种方法并去调用它时，它才能起作用。在三种打印方法的情况下，可能在参数的数量和类型的基础上对此进行区分。

通过重用方法名称，可用下述方法结束：

```
public void println(int i)
public void println(float f)
public void println()
```

当写代码来调用这些方法中的一种方法时，根据ᨀ供的参数的类型选择合适的一种方法。调用语句的参数表必须有足够的不同，以至于允许区分出正确的方法被调用。正常的拓展晋升（如，单精度类型 float 到双精度类型 double）可能被应用，但是这样会导致在某些条件下的混淆。这重载的方法主要通过形式参数列表中参数的个数、参数的数据类型和参数的顺序等方面的不同来区分。方法的

返回类型可以各不相同，但它不足以使返回类型变成唯一的差异。重载方法的参数表必须不同。

```
【动手做】请写出下面程序的输出结果。
public class c5_5 extends Applet
{ 
int add(int a,int b) //重载的方法 1
{ 
return(a+b);
}
double add(double x,double y) //重载的方法 2
{ 
return(x+y); 
}
double add(double x,double y, double z) //重载的方法 3
{ 
return(x+y+z); 
}
public void paint(Graphics g)
{ 
System.out.println("Sum is:"+add(8.5,2.3));
System.out.println ("Sum is:"+add(21,38));
System.out.println ("Sum is:"+add(8.5,2.3,8.5+2.3));
} 
}
【参考答案】
Sum	is:	10.8
Sum	is:	59
Sum	is:	21.6
```

### **抽象类**

在 Java 中还可以创建专门的类来作为父类，这种类被称作“抽象类“（Abstract	class）。抽象类有点类似“模板”的作用，其目的是根据他的格式来穿件和修改新的类。但是并不能直接由抽象类创建对象，只能通过抽象类派生出新的子类，再由其子类来创建对象。抽象类用 abstract	 关键字来修饰：

```
abstract class Shape { 
//定义抽象类Shape
double radius,length,width,height; 
abstract double vol(); // 抽象方法 vol
Shape(double r,double h){ // 定义构造方法
radius = r;
height = h;
}
}
```

注意：抽象方法不定义方法体

在定义抽象类时要注意：

1. 由于抽象类是需要被继承的，所以 abstract 类不能用 final 来修是。也就是说，一个类不能及时最终类，又是抽象类。

2. abstract 不能与 private	 、static、final 或者 native 并列修饰同一方法

3. 习惯上，在类的说明中，关键字 public	 或者 private 放在 final 或者abstract 的前面

抽象类中不一定包含抽象方法，担包含抽象方法的类一定要声明为抽象类。抽象类可以有构造方法，且构造方法可以被子类的构造方法多调用，但构造方法不能被声明为抽象的。由于不能用抽象类直接创建对象，因此一般不在抽象类内定义构造方法。

我们来看一个例子：计算底面半径为 2 高为 3 的圆柱体体积和长、宽、高分别为 3、2、4 的长方形体积。

```
abstract class Shape { // 定义抽象类 Shape
double radius,length,width,height; 
abstract double vol(); // 抽象方法 vol
Shape(double r,double h){ // 定义构造方法
radius = r;
height = h;
}
Shape(double l,double w,double h){
length = l;
width = w;
height = h;
}}
class Circle extends Shape{
Circle(double r,double h){
super(r,h);
}
double vol() { //在抽象类的子类中实现抽象方法
return(3.1416 * radius * radius * height);
}}
class Rectangle extends Shape {
Rectangle(double l,double w,double h){
super(l,w,h);
}
double vol() {
return(length * width * height);
}
class AbstractClassDemo {
public static void main(String args[]) {
Circle c = new Circle(2,3);
Rectangle r = new Rectangle(3,2,4);
System.out.println("圆柱体体积 = "+ c.vol());
System.out.println("长方体体积 = "+ r.vol());
}}
```

程序的运行结果如下：

圆柱体体积 =	37.6992

长方体体积 =	24.0

# **主题** **10**	 **接口和包**

【导语】

在前面我们学习了 Java 的继承和多态。在本主题中，我们将进一步介绍 Java 面向对象程序中的另一些重要概念：接口和包。接口是一系列抽象（abstract）方法和常量的集合。于是类（class）和接口(interface)它们处于同一个级别。两者非常相似，接口也封装了方法和属性。特殊的是，接口的方法都是抽象方法，接口的属性都是常量。接口的好处是，当类定义只能扩展出单个类时，它能实现所需的多个接口。包是 Java 语言提供的一种区别类名空间的机制，是一组相关的类和接口的集合。包中还可以再有子包，相当于文件夹中可以包含若干文件和子文件夹一样。Java 语言中的包把各种类组织在一起，使得程序功能清楚、结构分明。

## **模块 1 接口** 

**为什么要有接口机制** 

**多重继承**是指一个子类可以有多个直接父类，该子类可以全部或部分继承所有直接父类的数据成员及成员方法。在面向对象的程序设计语言中，有些语言（如 C++）提供了多继承机制。而 Java 出于安全性、简化程序结构的考虑，不支持类间的多继承而只支持单继承，即一个类只能有一个父类，这使程序的层次关系清晰、可读性强。然而在解决实际问题的过程中，在很多情况下仅仅依靠单继承不能将复杂的问题描述清楚。为了 Java 程序的类间层次结构更加合理，更符合实际问题的本质，Java 语言提供接口来实现多重继承机制。接口是一系列抽象（abstract）方法和常量的集合。于是类（class）和接口(interface)它们处于同一个级别。两者非常相似，接口也封装了方法和属性。

特殊的是，接口的方法都是抽象方法，接口的属性都是常量。接口的好处是，当类定义只能扩展出单个类时，它能实现所需的多个接口。其实接口就是给出一些没有内容的方法，到具体用的时候再由用的方法自己定义内容。**使用接口的好处，通过接口统一了类和类的交流方式。**在于

比如一台电脑：主板上的 PCI 插槽就是现实中的接口 ，由于主板的厂家和做各种卡的厂家都遵守了统一的规定，包括尺寸，排线等等，你可你把声卡，显卡，网卡都插在 PCI 插槽上，而不用担心那个插槽是专门插哪个的。

![image-20220721225540682](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220721225540682.png)



**声明接口** 

声明一个接口需要两个部分：接口声明和接口体。下面是一个典型的接口

声明：

```
public interface Cab extends Car{
//修饰符 接口名 父接口列表
//接口体
 public final static double RATE=3.245；
abstract double getPrice();
abstract double getDate();
}
```

接口修饰符是可选的。当没有修饰符时，表示此接口的访问只限于同包的类；如果使用修饰符，则只能用 public 修饰符，表示此接口是公共接口，可以被所有的类和接口使用。

接口声明中的 extends 关键词和类声明中的 extends 一样，用来定义直接的父接口。与类的继承不同的是一个接口可以继承多个父接口，它们之间用逗号分隔。

接口可以有 3 种成员：常量、抽象方法、内部类/内部接口。由于接口中的方法都是抽象方法，所以方法体仅仅有一个分号“;”，没有“{”和“}”。修饰符是可选的，它只能是 public 和 abstract。接口中的所有方法都隐含的是 public 和 abstract 的，接口的方法不能是带 static、final 等其他修饰符的。接口只能有常量声明，不能有实例变量。因此，所有定义在接口中的常量都是 public、static 和 final，而且必须在声明时给定初值。例如：*public	final	static	int	a=9**；*

从上面的格式可以看出，定义接口与定义类非常相似。实际上完全可以把接口理解成为一种特殊的类，接口是由常量和抽象方法组成的特殊类。一个类只能有一个父类，但是它可以同时实现若干个接口。这种情况下，如果把接口理解成特殊的类，那么这个类利用接口实际上就获得了多个父类，即实现了多重继承。

接口定义仅仅是实现某一特定功能的一组功能的对外接口和规范，而不能真正地实现这个功能，这个功能的真正实现是在“继承”这个接口的各个类中完成的，要由这些类来具体定义接口中各抽象方法的方法体。因而在 Java中，通常把对接口功能的“继承”称为“实现”。

总结以上讲解，我们在声明接口时，应注意：

（1）接口定义用关键字 interface，而不是用 class； 

（2）接口中定义的数据成员全是 final static，即常量；

（3）接口中没有自身的构造方法，所有成员方法都是抽象方法；

（4）接口也具有继承性，可以通过 extends 关键字声明该接口的父接口。

```
【试一试】
按照声明接口的规则，我们也来定义一个接口吧，定义一个名为 Shapes
接口，里面包含常量数据 PI 和 getArea()、getPerimeter()两个抽象方法
参考答案：
interface Shapes
{
public final static double PI=3.14159；
abstract double getArea();
abstract double getPerimeter();
}
```

### **实现接口** 

接口的声明仅仅给出了抽象方法，而具体地实现接口所定义的方法需要某

个类为接口中的每个抽象方法定义具体的操作。在某个继承接口的类中重写接

口中的抽象方法称为实现这个接口。

在类的声明部分，用 implements 关键字来声明这个类实现某个接口，一

个类可以实现多个接口，在 implements 子句中用逗号隔开。接口实现的语法

格式为：

```
class Triangle implements Shapes{
//类名   接口列表
 …
}
```

**一个类要实现一个接口时** 

如果实现某接口的类不是抽象类，则在类的定义部分必须实现指定接口的所有抽象方法，即为所有抽象方法定义方法体，而且方法头部分应该与接口中的定义完全一致，即有完全相同的返回值、访问控制和参数列表； 

例如：对于接口 Shapes，实现它的类 Triangle 可以写为

```
interface Shapes
{
public final static double PI=3.14159；
abstract double getArea();
abstract double getPerimeter();
}
class Triangle implements Shapes 
{
public int width,height;
public double getArea()
{
return(width*height);
}
public double getPerimeter()
{
return(2*width+2*height);
}
public Triangle (int width,int height)
{
this.width=width;
this.height=height;
} }
```

如果实现某接口的类是 abstract 的抽象类，则它可以不实现该接口所有的方法。但如果该抽象类有非抽象的子类，那在子类中必须实现接口的所有方法，即有实在的方法体。也就是说在此非抽象子类中不允许存在未被实现的接口方法。这主要体现了非抽象类中不能存在抽象方法的原则；接口的抽象方法的访问限制符都己指定为 public，所以类在实现方法时，必须显式地使用 public 修饰符，否则将被系统警告为缩小了接口中定义的方法的访问控制范围。

**一个类实现多个接口时** 

一个类可以调用多个接口，这时，在 implements 后用逗号隔开多个接口的名字；此时该类要同时实现其继承的多个接口的所有方法。

```
interface A
{
public final static int a=3；
abstract int getAA();
}
interface B
{
public final static float b=4.5；
abstract float getBB();
}
class C implements A,B{
public double getAA(){
return a;
}
public float getBB(){
return b;
} }
```

**接口的继承关系** 

接口也可以通过关键字 extends 继承其他接口。子接口将继承父接口中所有的常量和抽象方法。此时，实现子接口的非抽象类不仅需实现子接口的抽象方法，而且需实现继承来的抽象方法。不允许存在未被实现的接口方法。

例如：

```
interface A{
String a = "在接口 A 中";
void showA();
}
interface B extends A{
String b = "在接口 B 中";
void showB();
}
interface C extends B{
String c = "在接口 C 中";
void showC();
}
class D implements C{
public void showA(){
System.out.println(a);
}
public void showB(){
System.out.println(b);
} 
public void showC(){
System.out.println(c);
}
public static void main(String args[]){
D d = new D();
d.showA();
d.showB();
d.showC();
} }
```

程序运行结果如下：

在接口 A 中

在接口 B 中

在接口 C 中

在上面的例子中，由于 B 继承 A，C 继承 B，因此，C 中包括 a、b、c 三个

常量以及 showA()、showB()、showC()三个抽象方法。因此，当 D 实现接口 C

时，应当实现继承来所有抽象方法（showA()、showB()和 showC()）。

```
【动手做】
定义一个类 E 实现接口 B
参考答案：
class E implements B{
public void showA(){
System.out.println(a);
}
public void showB(){
System.out.println(b);
} 
}
```

在上面所举的例子中，你可能会发现即使不定义接口，各个类给出方法体，产生各自的行为，也可以实现相应的功能。那么，接口的意义到底在于什么地方呢？这是个不错的问题，即使不定义接口我们还是一样写代码，一样的做 。

可是企业级的开发可不是三两个人一天两天就能干完的，几百人的项目出来了，一个小公司干不了，就要把软件拆开分到很多小公司做，那怎么能保证各个公司做的代码最后和到一起能像我们想得那样运行呢？这里接口就体现了巨大的作用！ 我分给你的任务，我不管你内部具体怎么实现，只要你按着我给你定义好的接口写，到我要用的时候统一调用就不会出现众多人写的代码和不到一起去的情况，当然这说的只是接口最浅显的用处，当然在编程中接口对于带代码的可重用性，安全性，健壮性，可维护性等有着至关重要作用！

```
【做一做】
1.在 Java 中用_______ 来取代多重继承__________。
2.Java 接口中只包含________ 和_________。
3.定义接口的关键字是_________，实现接口的关键字是________ 。
4.以接口为类型时实际上是一种_________。
5.写出以下代码的输出值。
interface	Speskable{
public	void	speak();
}
interface	Runner{
public	void	run();
}
class	Dog	implements	Speskable,Runner{
public	void	speak(){
System.out.println(“狗的声音：汪、汪！”);
}
public	void	run(){
System.out.println(“狗用四肢跑步”);
}}
class	Person	implements	Speskable,Runner{
public	void	speak(){
System.out.println(“人们经常见面说：您好！”);
}
public	void	run(){
System.out.println(“人用两腿跑步”);
}}
public	class	TestInterface{
public	static	void	main(String	args[]){
Dog	d=new	Dog();
d.speak();d.run();
Person	p=new	Person();
p.speak();p.run();
}}
```

## **模块 2 包** 

### **包是干什么用的** 

在我们使用电脑时，为便于管理，我们通常将不同类型的文件存放在不同的目录中，比如我们可能会把 E 盘设为娱乐盘，其中又有若干文件夹：音乐、电影、电视剧、图片……每个文件夹下都放着各种歌曲、各种电影、各种图片等等。但如果我们试想我们不设这些文件夹，直接把各种歌曲、电影、图片都放在 E 盘下，会是怎么样呢？肯定会给我们的日常使用带来诸多不便。

包就类似于上面说的各种文件夹的概念。由于在 Java 中，开发人员通过类来实现各项功能，根据不同的需求设计出大量的各式各样的类，并将这些类杂乱无章的存放在各个文件中（就像把各种歌曲、电影、图片都统统混放在 E盘下一样）。当他们需要使用这些类的时候，往往很难分清哪些类是一组的或者相互继承的，这给程序的开发带来了很大的麻烦，为了避免这种情况的发生，Java 语言使用了一种新的机制来将这些类分门别类地集中到一起，这种机制就是“包”。

所谓包就是 Java 语言ᨀ供的一种区别类名空间的机制，是一组相关的类和接口的集合。包中还可以再有子包，相当于文件夹中可以包含若干文件和子文件夹一样。Java 语言中的包把各种类组织在一起，使得程序功能清楚、结构分明。

但是“包”的引入绝不仅仅只是单纯的把各种类分门别类地集中在一起，它还有以下作用：

1. 有效解决了类名冲突问题。当声明的类很多时，类名冲突的可能性很大，引入包后，只要一个包中的类名不冲突就可以，不同包中的类名可以相同。例如有两个人都叫王刚，如果他们在同一个办公室办公，就容易叫错人，如果在不同的办公室办公，这个重名问题就容易解决。

2. 包体现了 Java 语言面向对象特性中的封装机制，包将 java 语言的类和接口有机地组织成层次结构，这个层次结构与我们平常使用电脑时见到的具体的文件系统的目录树结构层次一致。因此，Java 包就是具有一定相关性在文件系统中可准确定位的 Java 文件的集合；

3. 包还可以控制类之间的访问。类之间的访问控制是通过类修饰符来实现的，若类声明修饰符 public，则表明该类不仅可供同一包中的类访问，也可以被其它包中的类访问。若类声明无修饰符，则表明该类仅供同一包中的类访问。在 Java 系统中已经包含了设计者编写的大量系统程序包，前面已介绍过的 java.io 、java.lang 等， 这些包中存放着一些常用的基本类，如System类、String 类、Math 类等，它们被称为 Java 类库中的包。我们除了了解如何使用系统程序包外，还要学习如何把自己编写的类组成程序包的形式，以便将来像使用系统程序包一样使用自己的程序包。

### **包的声明** 

为了声明一个包，首先必须建立一个相应的目录结构，子目录应与包名一致。然后在需要放入该包的类文件开头声明包，使用关键字 package 声明包。这样，这个类文件中定义的所有类就会都被装入到所需要的包中。例如：

```
package shape;//包名
class shapeCircle{ //类 shapeCircle 被装入了包 shape 中
……									
}
class shapeSquare { //类 shapeSquare 被装入了包 shape 中
……
}
class shapeTriangle{ //类 shapeTriangle 被装入了包 shape 中
……
}
```

关键字 package 后是不同层次的包名,在包名 1 下允许有次一级的子包— —包名 2，包名 2 下可以有更次一级的子包——包名 3 等等。各级包名之间用“.”号分隔。通常情况下，包名称的元素被整个地小写。例如：

*package	shape.shapeCircle**；*

这说明这个语句创建了两个文件夹，第一个是当前文件夹下的子文件夹shape；第二个是 shape 下的子文件夹 shapeCircle ，当前类文件中的所有类就存放在这个文件夹里，如下图：

![image-20220721231003836](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220721231003836.png)

```
【想一想】
如果我想在子文件夹 shapeCircle 中再创建一个文件夹 shapeCircle_1，然
后把当前类文件中的所有类都存在此文件夹中，我该如果写 package 语句呢？
参考答案：
 package shape.shapeCircle.shapeCircle_1
```

为了将不同的源程序放在同一个包中，我们可以在不同的文件中使用相同

的程序包声明语句。例如下面的类 Shapes 和类 shapeCircle 都被装入了包

shape 中。

文件名为 shapeSquare.java

```
package shape;
public interface shapeSquare
{
abstract double getArea();
abstract double getPerimeter();
}
```

（2）文件名为 shapeCircle.java

```
package shape;
class shapeCircle
{ 
public static void main(String[] args){
System.out.println(“Test package!”) } }
```

编译和运行带有 package 语句的源程序，情况稍复杂一些，我们在实际操作会经常发现，解释器常常返回“can’t find class”（找不到类）。这是因为，当程序中用 package 语句指明一个包时，需要将编译时产生的字节码文件（.class 文件）放到相应的目录下，可以手工建立子目录，再将.class 文

件复制到相应目录下。实际上在编译时，使用 javac 可以将.class 文件放入到相应的目录中，只需要使用命令选项-d 来指明包的根目录即可。

例如，假设包 shape 的根目录为“e:\1000”, shapeCircle.java 文件在”e:\1000\shape”目录下：

```
package shape;
class shapeCircle
{ 
public static void main(String[] args){
System.out.println(“Test package!”) } }
```

在**编译**时，可以使用：javac –d <类路径> <要编译的 java 源文件>

*javac	–d	e:\1000\shape	e:\1000\shape\shapeCircle.java*

在**运行**时，需要指明含有 main( )的类名；

*java	shape.shapeCircle*

下图演示了编译和运行包中类的过程。

![image-20220721231207919](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220721231207919.png)

在默认情况下，系统会为每个 java 源文件创建一个无名包，若源文件中未使用 package，该 java 文件中定义的所有类都隶属于这个无名包，它们之间可以相互引用非 private 的数据成员或成员方法。但是由于这个无名包是没有名字的，因此它不能被其他包所引用。

### **程序中引用包** 

将类组织成包的目的是为了更好地利用包中的类。通常一个类只能引用与它在同一个包中的类。如果需要使用其它包中的 public 类，则可以使用如下的几种方法。

1、在引入的类前加包名。对于同一包中的其它类可直接引用；对于不同包中的其它类引用时需在类名前加包名。例如，若在你的源文件中要引用包shape 中的类 Circle，并创建类 Circle 的对象 c，你可在源文件中的 Circle 之前加 “shape.”如：

shape.Circle	c=new	shape.Circle();

这种类名前加包名的引用方式适用于在源文件中使用少的情况。

2、用 import 关键字加载需要使用的类。上面方法使用起来比较麻烦。利用 import 关键字加载需要使用的类当前程序中，这样在程序中引用这个类的地方就不需要再使用包名作为前缀。例如上例中，如果在程序开始处增加了：

import shape.Circle；

语句之后，创建对象 c 时就可以直接写成：

Circle c=new Circle();

上面的方法利用 import 语句加载了其他包中的一个类。若希望引入整个包也可以直接利用 import 语句。加载整个包的 import 语句可以写为：

import shape.*； 

该语句的作用是把 shape 包中的所有类加载到当前程序中。与加载单个类相同，加载整个包后，凡是用这个包中的类，都不需要再使用包名前缀。

**如何设计包（补充阅读）** 

自下而上的包设计的几个原则：

1、共同重用原则。

对于使用者来说， 当依赖于一个包的时候， 应该是依赖于一个包中全部的类， 

而不是仅仅某一个类。换句话说， 包中的类应该是不可分开的。否则的话，包将直接影响使用者的不必要的重新发布和编译。这个原则能够避免包分得过于粗。

2、共同封闭原则

包中的类对于同一类性质的变化应该是共同封闭的。一个变化如果对一个包产生影响，那么他对包中的类都产生影响，而对于其他的包不产生影响。这个原则可以避免包分得过细。

3、包的依赖性原则：

1)无环依赖原则。在包的依赖图中不允许存在环。

2)稳定依赖原则。朝着稳定的方向进行依赖。如果改变一个事物需要很大的力气，也就是难以改变， 那么它就是稳定的。使一个类稳定的方法是让很多的类依赖于它，这样它就具有拒绝变化的 n 个理由，就是稳定的。相反，如果一个类没有任何类依赖于自己，反而依赖于其他的类，那么就是不稳定的。

3）稳定抽象原则。抽象类通常是很灵活的， 能够适应 OCP 的需求。 包的抽象程度应该跟它的稳定性一致。即：越是稳定的包，其中的类应该是最抽象的.

## **模块 3 打包（选学）** 

### **用 jar 命令打包 Jar 文件** 

当看到“打包”这个词时我们是不是有几分熟悉感呢？我们在日常使用电脑整理文件时，也会经常“打包”——将我们原先零散的东西放到一起，重新组织，用压缩软件压缩为一个压缩包（zip 文件）。jar 文件也是类似于 zip文件，也就是说它也是用来压缩的。这是 jar 的全称：Java TM Archive(JAR) 

file，即 java 存档文件。

一个 Jar 文件是一个独立的文件，它是一种 Java 运行环境可以快速访问的压缩格式。一个 JAR 文件可以有几个类，也可以有许多类。Jar 要压缩的主要是 class 文件，还有辅助的资源，这其中可能有图片，jsp 文件，html 文件等等。

JAR 文件通过 jar 工具创建。jar 工具也象 javac 等其他 java 命令行工具一样在 java 的 bin 目录下。

JAR 文件格式以流行的 zip 文件格式为基础。与 zip 文件不同的是，JAR 文件不仅用于压缩和发布，而且还用于部署和封装库、组件和插件程序，并可被像编译器和 JVM 这样的工具直接使用。在 JAR 中包含特殊的文件，如包含了一个 META-INF/MANIFEST.MF 文件，这个文件是在生成 JAR 文件的时候自动创建的，用来指示工具如何处理特定的 JAR。举个例子，如果我们具有如下目录结构的一些文件：

|-- test 

​        |-- Test.class 

​        把它压缩成 ZIP 文件 test.zip，则这个 ZIP 文件的内部目录结构为：

test.zip 

​        |-- test 

​                |-- Test.class 

如果我们使用 JDK 的 jar 命令把它打成 JAR 文件包 test.jar，则这个 JAR 

文件的内部目录结构为：

test.jar 

​      |-- META-INF 

​      |-- MANIFEST.MF 

​            -- test 

​            --Test.class 

一个 JAR 文件可以用于：

· 用于发布和使用类库

· 作为应用程序和扩展的构建单元

· 作为组件、applet 或者插件程序的部署单位

· 用于打包与组件相关联的辅助资源

### **创建可执行的 JAR 文件包** 

创建可执行的 JAR 文件包，需要使用带 cvfm 参数的 jar 命令，同样以上述 test 目录为例，命令如下：

jar cvfm test.jar manifest.mf test 

这里 test.jar 和 manifest.mf 两个文件，分别是对应的参数 f 和 m，其重头戏在 manifest.mf。因为要创建可执行的 JAR 文件包，光靠指定一个manifest.mf 文件是不够的，因为 MANIFEST 是 JAR 文件包的特征，可执行的 JAR 文件包和不可执行的 JAR 文件包都包含 MANIFEST。关键在于可执行

JAR 文件包的 MANIFEST，其内容包含了 Main-Class 一项。这在 MANIFEST 中

书写格式如下：

​        Main-Class: 可执行主类全名(包含包名) 

​        例如，假设上例中的 Test.class 是属于 test 包的，而且是可执行的类

(定义了 public static void main(String[]) 方法)，那么这个 manifest.mf 

可以编辑如下：

​        Main-Class: test.Test <回车>; 

​        这个 manifest.mf 可以放在任何位置，也可以是其它的文件名，只需要有 Main-Class: test.Test 一行，且该行以一个回车符结束即可。创建了manifest.mf 文件之后，我们的目录结构变为：

== 

|-- test 

| `-- Test.class 

`-- manifest.mf 

这时候，需要到 test 目录的上级目录中去使用 jar 命令来创建 JAR 文件包。也就是在目录树中使用“==”表示的那个目录中，使用如下命令：

jar cvfm test.jar manifest.mf test 

之后在“==”目录中创建了 test.jar，这个 test.jar 就是执行的 JAR 文件包。运行时只需要使用 java -jar test.jar 命令即可。需要注意的是，创建的 JAR 文件包中需要包含完整的、与 Java 程序的包结构对应的目录结构，就像上例一样。而 Main-Class 指定的类，也必须是完整的、包含包路径的类名，如上例的 test.Test；而且在没有打成 JAR 文件包之前可以使用 java <类名>; 来运行这个类，即在上例中 java test.Test 是可以正确运行的 (当然要在 CLASSPATH 正确的情况下)。

### **jar 命令详解** 

jar 是随 JDK 安装的，在 JDK 安装目录下的 bin 目录中，Windows 下文件名为 jar.exe，Linux 下文件名为 jar。它的运行需要用到 JDK 安装目录下 lib 目录中的 tools.jar 文件。不过我们除了安装 JDK 什么也不需要做，因为 SUN 已经帮我们做好了。我们甚至不需要将 tools.jar 放到CLASSPATH 中。

在 cmd 命令窗口下输入 jar，回车，就会ᨀ示改命令的用法：

![image-20220721232157978](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220721232157978.png)

使用不带任何的 jar 命令我们可以看到 jar 命令的用法如下：

jar {ctxu}[vfm0M] [jar-文件] [manifest-文件] [-C 目录] 文件名 ... 

其中 {ctxu} 是 jar 命令的子命令，每次 jar 命令只能包含 ctxu 中的一

个，它们分别表示：

-c 创建新的 JAR 文件包

-t 列出 JAR 文件包的内容列表

-x 展开 JAR 文件包的指定文件或者所有文件

-u 更新已存在的 JAR 文件包 (添加文件到 JAR 文件包中) 

[vfm0M] 中的选项可以任选，也可以不选，它们是 jar 命令的选项参数

-v 生成详细报告并打印到标准输出

-f 指定 JAR 文件名，通常这个参数是必须的

-m 指定需要包含的 MANIFEST 清单文件

-0 只存储，不压缩，这样产生的 JAR 文件包会比不用该参数产生的体积大，

但速度更快

-M 不产生所有项的清单（MANIFEST〕文件，此参数会忽略 -m 参数

[jar-文件] 即需要生成、查看、更新或者解开的 JAR 文件包，它是 -f 参数

的附属参数

[manifest-文件] 即 MANIFEST 清单文件，它是 -m 参数的附属参数

[-C 目录] 表示转到指定目录下去执行这个 jar 命令的操作。它相当于先使

用 cd 命令转该目录下再执行不带 -C 参数的 jar 命令，它只能在创建和更

新 JAR 文件包的时候可用。

文件名 ... 指定一个文件/目录列表，这些文件/目录就是要添加到 JAR 文件

包中的文件/目录。如果指定了目录，那么 jar 命令打包的时候会自动把该目

录中的所有文件和子目录打入包中。

下面举一些例子来说明 jar 命令的用法：

**（1） jar cf test.jar test** 

该命令没有执行过程的显示，执行结果是在当前目录生成了 test.jar 文

件。如果当前目录已经存在 test.jar，那么该文件将被覆盖。

**（2） jar cvf test.jar test** 

该命令与上例中的结果相同，但是由于 v 参数的作用，显示出了打包过

程，如下：

标明清单(manifest) 

增加：test/(读入= 0) (写出= 0)(存储了 0%) 

增加：test/Test.class(读入= 7) (写出= 6)(压缩了 14%) 

**（3） jar cvfM test.jar test** 

该命令与 2) 结果类似，但在生成的 test.jar 中没有包含

META-INF/MANIFEST 文件，打包过程的信息也略有差别：

增加：test/(读入= 0) (写出= 0)(存储了 0%) 

增加：test/Test.class(读入= 7) (写出= 6)(压缩了 14%) 

**（4） jar cvfm test.jar manifest.mf test** 

运行结果与 2) 相似，显示信息也相同，只是生成 JAR 包中的

META-INF/MANIFEST 内容不同，是包含了 manifest.mf 的内容

**（5） jar tf test.jar** 

在 test.jar 已经存在的情况下，可以查看 test.jar 中的内容，如对于

2) 和 3) 生成的 test.jar 分别应该此命令，结果如下；

对于 2) 

META-INF/ 

META-INF/MANIFEST.MF 

test/ 

test/Test.class 

对于 3) 

test/ 

test/Test.class 

**（6）jar tvf test.jar** 

除显示 5) 中显示的内容外，还包括包内文件的详细信息，如：

0 Wed Jun 19 15:39:06 GMT 2002 META-INF/ 

86 Wed Jun 19 15:39:06 GMT 2002 META-INF/MANIFEST.MF 

0 Wed Jun 19 15:33:04 GMT 2002 test/ 

7 Wed Jun 19 15:33:04 GMT 2002 test/Test.class 

**（7） jar xf test.jar** 

解开 test.jar 到当前目录，不显示任何信息，对于 2) 生成的

test.jar，解开后的目录结构如下：

== 

|-- META-INF 

| `-- MANIFEST 

`-- test 

`--Test.class 

**（8） jar xvf test.jar** 

运行结果与 7) 相同，对于解压过程有详细信息显示，如：

创建：META-INF/ 

展开：META-INF/MANIFEST.MF 

创建：test/ 

展开：test/Test.class 

**（9）jar uf test.jar manifest.mf** 

在 test.jar 中添加了文件 manifest.mf，此使用 jar tf 来查看

test.jar 可以发现 test.jar 中比原来多了一个 manifest。这里顺便ᨀ一

下，如果使用 -m 参数并指定 manifest.mf 文件，那么 manifest.mf 是作为

清单文件 MANIFEST 来使用的，它的内容会被添加到 MANIFEST 中；但是，如

果作为一般文件添加到 JAR 文件包中，它跟一般文件无异。

**（10） jar uvf test.jar manifest.mf** 

与 9) 结果相同，同时有详细信息显示，如：

增加：manifest.mf(读入= 17) (写出= 19)(压缩了 -11%) 

**关于 JAR 文件包的一些技巧** 

（1） 使用 unzip 来解压 JAR 文件

在介绍 JAR 文件的时候就已经说过了，JAR 文件实际上就是 ZIP 文件，

所以可以使用常见的一些解压 ZIP 文件的工具来解压 JAR 文件，如 Windows 

下的 WinZip、WinRAR 等和 Linux 下的 unzip 等。使用 WinZip 和 WinRAR 

等来解压是因为它们解压比较直观，方便。而使用 unzip，则是因为它解压时

可以使用 -d 参数指定目标目录。

在解压一个 JAR 文件的时候是不能使用 jar 的 -C 参数来指定解压的

目标的，因为 -C 参数只在创建或者更新包的时候可用。那么需要将文件解压

到某个指定目录下的时候就需要先将这具 JAR 文件拷贝到目标目录下，再进

行解压，比较麻烦。如果使用 unzip，就不需要这么麻烦了，只需要指定一个

-d 参数即可。如：

unzip test.jar -d dest/ 

（

2） 使用 WinZip 或者 WinRAR 等工具创建 JAR 文件

上面ᨀ到 JAR 文件就是包含了 META-INF/MANIFEST 的 ZIP 文件，所以，只

需要使用 WinZip、WinRAR 等工具创建所需要 ZIP 压缩包，再往这个 ZIP 压

缩包中添加一个包含 MANIFEST 文件的 META-INF 目录即可。对于使用 jar 

命令的 -m 参数指定清单文件的情况，只需要将这个 MANIFEST 按需要修改即

可。

 

**关于** **java** **的笑话**

面试官：熟悉哪种语言

应聘者：Java。

面试官：知道什么叫类么

应聘者：我这人实在，工作努力，不知道什么叫累

面试官：知道什么是包? 

应聘者：我这人实在 平常不带包 也不用公司准备了

面试官：知道什么是接口吗? 

应聘者：我这个人工作认真。从来不找借口偷懒

面试官：知道什么是继承么

应聘者：我是孤儿没什么可以继承的

面试官:知道什么叫对象么？

应聘者:知道，不过我工作努力，上进心强，暂时还没有打算找对象。

面试官：知道多态么？

应聘者：知道，我很保守的。我认为让心爱的女人为了自已一时的快乐去堕胎

是不道德的行为！ 请问这和 Java 有什么关系？？

面试官：用过 apache 的东西吗

应聘者：我修过车子

面试官:了解 jakarta 的哪些项目？

应聘者:不了解，我只去那儿旅游过。

面试官：用过 spring 么？

应聘者：没用过，发过。

面试官：知道 Hibernate 吗

应聘者：知道，动物冬天经常 Hibernate,但我从来不冬眠

面试官：知道 css 吗? 

应聘者：cs 出加强版了？

面试官：OCR 用作过没？

应聘者：我从不玩魔兽

面试官：W3C 标准常用什么地方

应聘者：Lost Tample 

面试官：知道 REST 么？

应聘者：我很勤奋，只知道干活，不知道休息。

**趣闻：程序员，你上的是哪条船？**

如果将编程语言比作一条船，那么程序员又将扮演一个什么样的角色？是载舟

的水，还是坐船的人？

Turing

图灵无疑是一条独木舟，它很小并且需要纯手工驱动。这是一条适合初学者

的“船”。

![image-20220721232316380](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220721232316380.png)

Java



Java	 是一条货船。它的体积庞大、承载量大，非常企业级。不过在运行一个

项目时，操作并不那么顺手。

![image-20220721232340854](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220721232340854.png)

Perl

Perl 是一艘拖船。它有足够的动力来拖动 Java 正常运行。

![image-20220721232356471](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220721232356471.png)

Ruby

Ruby	 很难描述，它是圆滑的、性感的、顺手的和新潮的。

![image-20220721232411252](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220721232411252.png)

PHP

PHP 是一个竹筏。由一连串的 hacks 连成一体，仍将保持下去。

![image-20220721232431512](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220721232431512.png)

C

C	 是一艘核潜艇。虽然说明不好理解，不过可以优化硬件的性能。

![image-20220721232446393](C:\Users\wzn\AppData\Roaming\Typora\typora-user-images\image-20220721232446393.png)

HTML

HTML 也许不能称之为一个真正的编程语言。

HTML

HTML 也许不能称之为一个真正的编程语言。
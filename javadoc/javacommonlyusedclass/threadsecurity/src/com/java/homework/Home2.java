package com.java.homework;

/**
 * 银行有一个账户，账户中有10000块钱。
 * 有两个储户一起从该账户取钱，每次取100，每次取完打印账户余额。
 *
 *    1.这个空隙比较短，出现问题的几率比较小(睡眠时为了把空隙放大)
 *    2.在实际开发中肯定是没有这个睡眠的，但是空隙依然在，只是比较小，出现错误的几率比较低(那么我们也是不允许的)
 *    3.百分之百没有错误-->怎么解决？同步锁的方式去处理
 *         让重要的代码(处理共享资源的代码)对于多线程来说，只能由一个线程具备整个的执行流程
 *         取钱的n步是一个整体，哪个线程先抢到取钱的时间片，这个线程就有权利执行完整个取钱过程！
 *         其他线程应该进行等待，等待上述线程执行完后，在执行
 *
 *     问题：
 *         这里有点不够严密，如果只有90块钱也能进去，但是操作完就成了负数
 *           balance >= 100时才让他进入循环可以解决不   可以
 *           加睡眠放大不理解。。  一会画个图，在理解一下
 *
 *     线程安全的问题：
 *        1. 睡眠是增加线程多次执行之间的间隙还是增加同一次线程执行run中不同代码之间的间隙？
 *
 *        2. 睡眠放if上面和不加睡眠效果差不多把   对的，但是同样存在线程安全问题
 *
 *        3.  除了睡眠是我们定的时间，其他每行代码执行的时间长短是固定的么？ 不是固定的(不能通过计算时间去完成功能)
 *         如果两个线程同时走到sout会一前一后打印么？//有可能 println是一个方法(方法中存在多行代码)
 *
 *     问题：
 *         //是否懂出现负数？    0   -100
 *         //是否懂数显重复的数据   1000     980  980
 *         //顺便讲一下上面钱少下面钱多的问题？线程后来者居上(打印的方法也是多行代码[println()])
 */
public class Home2 {

    public static void main(String[] args) {
        //账户就是我们的目标    创建了两个账户(账户中的余额想要让两个储户去共享，就得设置静态资源)
        Account a1=new Account();
        a1.start();

        Account a2=new Account();
        a2.start();
    }
}

class Account extends Thread{
    private static double balance=1000;

    /*
    //加上一个睡眠，是放大我们的线程不安全的效果(会发现有重复的现象，还会有负数的现象)
    //线程的不安全
     */
    @Override
    public void run() {
        //取钱的操作(取钱的次数是不确定的)
        while(true){
            if(balance<=0){
                break;
            }
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //取钱操作
            balance-=100;
            System.out.println(Thread.currentThread().getName()+"取了100块钱,剩余："+balance);
        }
    }
}

